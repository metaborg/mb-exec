module build

imports
  base
  stratego-signatures
  shared
  aterm
  util

signature
  internal-sorts
    Builder
    
  internal-constructors
    b : PreTerm -> Builder
    bl : List(STerm) -> Builder

  arrows
    Builder -bld-> T
    Builder -blds-> List(T)

rules // build

  TF tf |- Build(Anno(t, as)) --> S(aterm)
  where
    b(t) -bld-> at,
    b(as) -bld-> aas, // FIXME
    isATermList(aas) == true,
    asATermList(aas) => aas',
    annotateTerm[tf](at, aas') => aterm
  
  Build(Var(x)) --> v
  where
    b(Var(x)) -bld-> t,
    S(t) => v

rules // actual term building

  E env |- b(Var(x)) -bld-> t
  where
    E env |- lookup(x) -look-> v,
    v => S(t) // the lookup has to be successful
      
  TF tf |- b(Int(i)) -bld-> aint
  where
    makeInt[tf](i) => aint
  
  TF tf |- b(Str(s)) -bld-> astr
  where
    makeString[tf](s) => astr
  
  TF tf |- b(Op(cname, ts)) -bld-> appl
  where
    length(ts) => numts,
    makeConstructor[tf](cname, numts) => constr,
    bl(ts) -blds-> ts',
    makeAppl(tf, constr, ts') => appl
  
  // cname_expr can be a Var or an Anno
  // ts_expr can a Var or an Anno
  TF tf |- b(Explode(cname_expr, ts_expr)) -bld-> appl
  where
    Build(cname_expr) --> S(cname_aterm),
    isATermString(cname_aterm) == true,
    asATermString(cname_aterm) => cname_aterm_str,
    stringValue[cname_aterm_str]() => cname,
    Build(ts_expr) --> S(ts_aterm),
    isATermList(ts_aterm) == true,
    asATermList(ts_aterm) => ts_aterm_list,
    size[ts_aterm_list]() => ts_aterm_list_len,
    makeConstructor[tf](cname, ts_aterm_list_len) => constr,
    toNativeList(ts_aterm_list) => ts_list_aterm,
    makeAppl(tf, constr, ts_list_aterm) => appl

  TF tf |- bl([]) -blds-> []

  TF tf |- bl([texpr | texprs]) -blds-> [tx | txs]
  where
    Build(texpr) --> S(tx),
    bl(texprs) -blds-> txs
