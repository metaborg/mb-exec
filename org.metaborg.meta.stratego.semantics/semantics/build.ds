module build

imports
  base
  stratego-signatures
  shared
  aterm
  environment

signature
  sorts
    Builder
  
  internal-sorts
    BuildRes
    
  internal-constructors
    b   : PreTerm -> Builder
    bl  : List(STerm) -> Builder

    BS  : T -> BuildRes
    BSS : List(T) -> BuildRes
    BF  : -> BuildRes
    
  arrows
    Builder -bld-> BuildRes
    Builder -blds-> BuildRes

rules // build

  TF tf |- Build(Anno(t, annos)) --> S(aterm)
  where
    b(t) -bld-> BS(at),
    b(annos) -bld-> BS(annos_aterm),
    isATermList(annos_aterm) == true,
    asATermList(annos_aterm) => annos_aterm_list,
    annotateTerm[tf](at, annos_aterm_list) => aterm
  
  Build(Var(x)) --> S(t)
  where
    b(Var(x)) -bld-> BS(t)
  
  Build(e) --> F()
  where
    all-fail

rules // actual term building

  E env |- b(Var(x)) -bld-> BS(t)
  where
    E env |- lookup(x) -look-> S(t)
      
  TF tf |- b(Int(stringI)) -bld-> BS(aint)
  where
    parseInt(stringI) => i',
    makeInt[tf](i') => aint
  
  TF tf |- b(Str(s)) -bld-> BS(astr)
  where
    makeString[tf](s) => astr
  
  // cname_expr can be a Var or an Anno
  // ts_expr can a Var or an Anno
  TF tf |- b(Explode(cname_expr, ts_expr)) -bld-> BS(appl)
  where
    Build(cname_expr) --> S(cname_aterm),
    isATermString(cname_aterm) == true,
    asATermString(cname_aterm) => cname_aterm_str,
    stringValue[cname_aterm_str]() => cname,
    Build(ts_expr) --> S(ts_aterm),
    isATermList(ts_aterm) == true,
    asATermList(ts_aterm) => ts_aterm_list,
    size[ts_aterm_list]() => ts_aterm_list_len,
    makeConstructor[tf](cname, ts_aterm_list_len) => constr,
    getAllSubterms[ts_aterm_list]() => tarray,
    makeAppl[tf](constr, tarray) => appl

  TF tf |- b(x) -bld-> BF()
  where
    all-fail

  TF tf |- bl([]) -blds-> BSS(asNILofT([]))

  TF tf |- bl([texpr | texprs]) -blds-> BSS([tx | txs])
  where
    Build(texpr) --> S(tx), // tx may be an ATerm list (if it's a varexpr)
    bl(texprs) -blds-> BSS(txs)
  
  TF tf |- bl(x) -blds-> BF()
  where
    all-fail

signature
  internal-constructors
    bAppl : PreTerm -> Builder
    bList : PreTerm -> Builder
    
rules

  TF tf |- b(Op(c, ts)) -bld-> bv
  where
    c == "Nil",
    length(ts) == 0,
    TF tf |- bList(Op(c, ts)) -bld-> bv
  
  // Appl dispatch
  TF tf |- b(Op(c, ts)) -bld-> bv
  where
    c == "Nil",
    length(ts) != 0,
    bAppl(Op(c, ts)) -bld-> bv

  TF tf |- b(Op(c, ts)) -bld-> bv
  where
    c == "Cons",
    length(ts) == 2,
    bList(Op(c, ts)) -bld-> bv
  
  TF tf |- bList(Op(c, ts)) -bld-> BS(nil)
  where
    ts => [],
    makeNil(tf) => nil
  
  TF tf |- bList(Op(c, ts)) -bld-> BS(list)
  where
    ts => [t1, t2],
    TF tf |- Build(t1) --> S(head),
    TF tf |- Build(t2) --> S(tail),
    isATermList(tail) == true,
    asATermList(tail) => tail',
    makeListCons[tf](head, tail') => list

  // Appl dispatch
  TF tf |- b(Op(c, ts)) -bld-> bv
  where
    c == "Cons",
    length(ts) != 2,
    bAppl(Op(c, ts)) -bld-> bv
  
  TF tf |- b(Op(c, ts)) -bld-> BS(tup)
  where
    c == "",
    TF tf |- bl(ts) -blds-> BSS(ts'),
    List2TARRAY(ts') => ts'',
    makeTuple[tf](ts'') => tup

  // Appl dispatch
  TF tf |- b(Op(c, ts)) -bld-> bv
  where
    c != "Cons",
    c != "Nil",
    c != "",
    bAppl(Op(c, ts)) -bld-> bv
  
  // NB: specialization possible on constant length(ts)
  TF tf |- bAppl(Op(c, ts)) -bld-> BS(appl)
  where
    length(ts) => numts,
    makeConstructor[tf](c, numts) => constr,
    bl(ts) -blds-> BSS(ts'),
    List2TARRAY(ts') => ts'',
    makeAppl[tf](constr, ts'') => appl
  
  TF tf |- bAppl(t) -bld-> BF()
  where all-fail
  
signature
  native-operators
    importTerm : String -> T

rules // import term

  ImportTerm(p) --> S(t)
  where
    importTerm(p) => t
