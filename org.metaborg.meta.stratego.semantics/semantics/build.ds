module build

imports
  base
  stratego-signatures
  shared
  aterm
  state

signature
  internal-sorts
    Builder
    BuildRes
    
  internal-constructors
    b   : PreTerm -> Builder
    bl  : List(STerm) -> Builder

    BS  : T -> BuildRes
    BSS : List(T) -> BuildRes
    BF  : -> BuildRes
    
  arrows
    Builder -bld-> BuildRes
    Builder -blds-> BuildRes

rules // build

  TF tf |- Build(Anno(t, annos)) --> S(aterm)
  where
    b(t) -bld-> BS(at),
    b(annos) -bld-> BS(annos_aterm),
    isATermList(annos_aterm) == true,
    asATermList(annos_aterm) => annos_aterm_list,
    annotateTerm[tf](at, annos_aterm_list) => aterm
  
  Build(Var(x)) --> S(t)
  where
    b(Var(x)) -bld-> BS(t)
  
  Build(e) --> F()
  where
    all-fail

rules // actual term building

  VEnv e |- b(Var(x)) -bld-> BS(t)
  where
    VLookup(e, x) -vlook-> VLookupResult(e', S(t))
      
  TF tf |- b(Int(stringI)) -bld-> BS(aint)
  where
    parseInt(stringI) => i',
    makeInt[tf](i') => aint
  
  TF tf |- b(Real(stringR)) -bld-> BS(areal)
  where
    parseReal(stringR) => r',
    makeReal[tf](r') => areal
  
  TF tf |- b(Str(s)) -bld-> BS(astr)
  where
    makeString[tf](s) => astr
  
  // Implode Int
  TF tf |- b(Explode(cname_expr, ts_expr)) -bld-> BS(c)
  where
    Build(cname_expr) --> S(c),
    Build(ts_expr) --> S(ts), // just to make sure we cause the right side-effects
    isATermList(ts) == true,
    isATermInt(c) == true
  
  // TODO Implode Real
  
  // Implode List
  TF tf |- b(Explode(cname_expr, ts_expr)) -bld-> BS(ts)
  where
    Build(cname_expr) --> S(c),
    Build(ts_expr) --> S(ts),
    isATermList(ts) == true,
    isATermList(c) == true
  
  // Implode Tuple
  TF tf |- b(Explode(cname_expr, ts_expr)) -bld-> BS(tupl)
  where
    Build(cname_expr) --> S(c),
    Build(ts_expr) --> S(ts),
    isATermList(ts) == true,
    isATermString(c) == true,
    asATermString(c) => tc,
    stringValue[tc]() => cname,
    cname == "",
    makeTuple[tf](getAllSubterms[ts]()) => tupl

  // Implode String
  TF tf |- b(Explode(cname_expr, ts_expr)) -bld-> BS(s)
  where
    Build(cname_expr) --> S(c),
    Build(ts_expr) --> S(ts),
    isATermList(ts) == true,
    isATermString(c) == true,
    asATermString(c) => tc,
    stringValue[tc]() => cname,
    isQuotedString(cname) == true,
    unquoteString(cname) => svalue,
    makeString[tf](svalue) => s
  
  // Implode Appl
  TF tf |- b(Explode(cname_expr, ts_expr)) -bld-> BS(appl)
  where
    Build(cname_expr) --> S(c),
    Build(ts_expr) --> S(ts),
    isATermList(ts) == true,
    isATermString(c) == true,
    asATermString(c) => tc,
    stringValue[tc]() => cname,
    isQuotedString(cname) == false,
    asATermList(ts) => tslist,
    makeConstructor[tf](cname, size[tslist]()) => constr,
    getAllSubterms[ts]() => kids,
    makeAppl[tf](constr, kids) => appl

  TF tf |- b(x) -bld-> BF()
  where
    all-fail

  TF tf |- bl([]) -blds-> BSS(asNILofT([]))

  TF tf |- bl([texpr | texprs]) -blds-> BSS([tx | txs])
  where
    Build(texpr) --> S(tx), // tx may be an ATerm list (if it's a varexpr)
    bl(texprs) -blds-> BSS(txs)
  
  TF tf |- bl(x) -blds-> BF()
  where
    all-fail

signature
  internal-constructors
    bAppl : PreTerm -> Builder
    bList : PreTerm -> Builder
    
rules

  TF tf |- b(Op(c, ts)) -bld-> bv
  where
    c == "Nil",
    length(ts) == 0,
    TF tf |- bList(Op(c, ts)) -bld-> bv
  
  // Appl dispatch
  TF tf |- b(Op(c, ts)) -bld-> bv
  where
    c == "Nil",
    length(ts) != 0,
    bAppl(Op(c, ts)) -bld-> bv

  TF tf |- b(Op(c, ts)) -bld-> bv
  where
    c == "Cons",
    length(ts) == 2,
    bList(Op(c, ts)) -bld-> bv
  
  TF tf |- bList(Op(c, ts)) -bld-> BS(nil)
  where
    ts => [],
    makeNil(tf) => nil
  
  TF tf |- bList(Op(c, ts)) -bld-> BS(list)
  where
    ts => [t1, t2],
    TF tf |- Build(t1) --> S(head),
    TF tf |- Build(t2) --> S(tail),
    isATermList(tail) == true,
    asATermList(tail) => tail',
    makeListCons[tf](head, tail') => list

  // Appl dispatch
  TF tf |- b(Op(c, ts)) -bld-> bv
  where
    c == "Cons",
    length(ts) != 2,
    bAppl(Op(c, ts)) -bld-> bv
  
  TF tf |- b(Op(c, ts)) -bld-> BS(tup)
  where
    c == "",
    TF tf |- bl(ts) -blds-> BSS(ts'),
    List2TARRAY(ts') => ts'',
    makeTuple[tf](ts'') => tup

  // Appl dispatch
  TF tf |- b(Op(c, ts)) -bld-> bv
  where
    c != "Cons",
    c != "Nil",
    c != "",
    bAppl(Op(c, ts)) -bld-> bv
  
  // NB: specialization possible on constant length(ts)
  TF tf |- bAppl(Op(c, ts)) -bld-> BS(appl)
  where
    length(ts) => numts,
    makeConstructor[tf](c, numts) => constr,
    bl(ts) -blds-> BSS(ts'),
    List2TARRAY(ts') => ts'',
    makeAppl[tf](constr, ts'') => appl
  
  TF tf |- bAppl(t) -bld-> BF()
  where all-fail
  
signature
  native-operators
    importTerm : IC * String -> T

rules // import term

  IC ic |- ImportTerm(p) --> S(t)
  where
    importTerm(ic, p) => t
