module build

imports
  base
  stratego-signatures
  shared
  aterm
  environment

signature
  sorts
    Builder
    
  internal-constructors
    b : PreTerm -> Builder
    bl : List(STerm) -> Builder

  arrows
    Builder -bld-> T
    Builder -blds-> List(T)

rules // build

  TF tf |- Build(Anno(t, annos)) --> S(aterm)
  where
    b(t) -bld-> at,
    b(annos) -bld-> annos_aterm,
    isATermList(annos_aterm) == true,
    asATermList(annos_aterm) => annos_aterm_list,
    annotateTerm[tf](at, annos_aterm_list) => aterm
  
  Build(Var(x)) --> v
  where
    b(Var(x)) -bld-> t,
    S(t) => v

rules // actual term building

  E env |- b(Var(x)) -bld-> t
  where
    E env |- lookup(x) -look-> v,
    v => S(t)
      
  TF tf |- b(Int(stringI)) -bld-> aint
  where
    parseInt(stringI) => i',
    makeInt[tf](i') => aint
  
  TF tf |- b(Str(s)) -bld-> astr
  where
    makeString[tf](s) => astr
  
  // build list (nil)
  TF tf |- b(Op(c, ts)) -bld-> nil
  where
    c == "Nil",
    makeNil(tf) => nil
  
  // build list (cons)
  TF tf |- b(Op(c, ts)) -bld-> list
  where
    c == "Cons",
    ts => [t1, t2],
    TF tf |- Build(t1) --> S(head),
    TF tf |- Build(t2) --> S(tail),
    isATermList(tail) == true,
    asATermList(tail) => tail',
    makeListCons[tf](head, tail') => list
    
  // NB: specialization possible on constant length(ts)
  TF tf |- b(Op(c, ts)) -bld-> appl
  where
    c != "Nil",
    c != "Cons",
    length(ts) => numts,
    makeConstructor[tf](c, numts) => constr,
    bl(ts) -blds-> ts',
    List2TARRAY(ts') => ts'',
    makeAppl[tf](constr, ts'') => appl
  
  // cname_expr can be a Var or an Anno
  // ts_expr can a Var or an Anno
  TF tf |- b(Explode(cname_expr, ts_expr)) -bld-> appl
  where
    Build(cname_expr) --> S(cname_aterm),
    isATermString(cname_aterm) == true,
    asATermString(cname_aterm) => cname_aterm_str,
    stringValue[cname_aterm_str]() => cname,
    Build(ts_expr) --> S(ts_aterm),
    isATermList(ts_aterm) == true,
    asATermList(ts_aterm) => ts_aterm_list,
    size[ts_aterm_list]() => ts_aterm_list_len,
    makeConstructor[tf](cname, ts_aterm_list_len) => constr,
    getAllSubterms[ts_aterm_list]() => tarray,
    makeAppl[tf](constr, tarray) => appl

  TF tf |- bl([]) -blds-> asNILofT([])

  TF tf |- bl([texpr | texprs]) -blds-> [tx | txs]
  where
    Build(texpr) --> S(tx), // tx may be an ATerm list (if it's a varexpr)
    bl(texprs) -blds-> txs
