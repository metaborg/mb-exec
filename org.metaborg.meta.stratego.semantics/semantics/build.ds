module build

imports
  semantics/stratego-signatures
  semantics/shared
  semantics/aterm
  semantics/state

signature
  sorts
    Builder
    BuildRes
    
  constructors
    BS  : T -> BuildRes
    BSS : List(T) -> BuildRes
    BF  : BuildRes
    
  arrows
    PreTerm -bld-> BuildRes

rules // build

  TF tf |- Build(Anno(t, annos)) --> S(aterm)
  where
    t -bld-> BS(at);
    annos -bld-> BS(annos_aterm);
    annos_aterm <: TLIST;
    annotateTerm[tf](at, annos_aterm) => aterm.
  
  Build(Var(x)) --> S(t)
  where
    Var(x) -bld-> BS(t).
  
  Build(_) --> F()
  where all-fail.

rules // actual term building

  Var(x) -bld-> BS(t)
  where
    VLookup(x) -vlook-> S(t).
      
  TF tf |- Int(stringI) -bld-> BS(aint)
  where
    parseInt(stringI) => i';
    makeInt[tf](i') => aint.
  
  TF tf |- Real(stringR) -bld-> BS(areal)
  where
    parseReal(stringR) => r';
    makeReal[tf](r') => areal.
  
  TF tf |- Str(s) -bld-> BS(astr)
  where
    makeString[tf](s) => astr.
  
  // Implode Int
  Explode(cname_expr, ts_expr) -bld-> BS(c)
  where
    Build(cname_expr) --> S(c);
    Build(ts_expr) --> S(ts); // just to make sure we cause the right side-effects
    ts <: TLIST;
    c <: TINT.
  
  // TODO Implode Real
  
  // Implode List
  Explode(cname_expr, ts_expr) -bld-> BS(ts)
  where
    Build(cname_expr) --> S(c);
    Build(ts_expr) --> S(ts);
    ts <: TLIST;
    c <: TLIST.
  
  // Implode Tuple
  TF tf |- Explode(cname_expr, ts_expr) -bld-> BS(tupl)
  where
    Build(cname_expr) --> S(c);
    Build(ts_expr) --> S(ts);
    ts <: TLIST;
    c <: TSTR;
    stringValue[c]() => cname;
    cname == "";
    makeTuple[tf](getAllSubterms[ts]()) => tupl.

  // Implode String
  TF tf |- Explode(cname_expr, ts_expr) -bld-> BS(s)
  where
    Build(cname_expr) --> S(c);
    Build(ts_expr) --> S(ts);
    ts <: TLIST;
    c <: TSTR;
    stringValue[c]() => cname;
    isQuotedString(cname) == true;
    unquoteString(cname) => svalue;
    makeString[tf](svalue) => s.
  
  // Implode Appl
  TF tf |- Explode(cname_expr, ts_expr) -bld-> BS(appl)
  where
    Build(cname_expr) --> S(c);
    Build(ts_expr) --> S(ts);
    ts <: TLIST;
    c <: TSTR;
    stringValue[c]() => cname;
    isQuotedString(cname) == false;
    makeConstructor[tf](cname, size[ts]()) => constr;
    getAllSubterms[ts]() => kids;
    makeAppl[tf](constr, kids) => appl.

  _ : PreTerm -bld-> BF().

signature
  arrows
    List(STerm) -blds-> BuildRes

rules

  [] : List(STerm) -blds-> BSS([]). // FIX

  [texpr | texprs] : List(STerm) -blds-> BSS([tx | txs]) // FIX
  where
    Build(texpr) --> S(tx); // tx may be an ATerm list (if it's a varexpr)
    texprs -blds-> BSS(txs).
  
  _ : List(STerm) -blds-> BF()
  where all-fail.

signature
  arrows
    PreTerm -bldlst-> BuildRes
    PreTerm -bldappl-> BuildRes

rules

  op@Op("Nil", ts) -bld-> bv
  where
    length(ts) == 0;
    op -bldlst-> bv.
  
  // Appl dispatch
  op@Op("Nil", ts) -bld-> bv
  where
    length(ts) != 0;
    op -bldappl-> bv.

  op@Op("Cons", ts) -bld-> bv
  where
    length(ts) == 2;
    op -bldlst-> bv.
  
  TF tf |- Op(_, []) -bldlst-> BS(nil)
  where
    makeNil(tf) => nil.

  TF tf |- Op(_, [t1, t2]) -bldlst-> BS(makeListCons[tf](head, tail))
  where
    TF tf |- Build(t1) --> S(head);
    TF tf |- Build(t2) --> S(tail);
    tail <: TLIST.

  // Appl dispatch
  op@Op("Cons", ts) -bld-> bv
  where
    length(ts) != 2;
    op -bldappl-> bv.
  
  TF tf |- Op("", ts) -bld-> BS(makeTuple[tf](ts''))
  where
    TF tf |- ts -blds-> BSS(ts');
    List2TARRAY(ts') => ts''.

  // Appl dispatch
  Op(c, ts) -bld-> bv
  where
    c != "Cons";
    c != "Nil";
    c != "";
    Op(c, ts) -bldappl-> bv.
  
  // NB: specialization possible on constant length(ts)
  TF tf |- Op(c, ts) -bldappl-> BS(appl)
  where
    length(ts) => numts;
    makeConstructor[tf](c, numts) => constr;
    ts -blds-> BSS(ts');
    List2TARRAY(ts') => ts'';
    makeAppl[tf](constr, ts'') => appl.
  
  _ : PreTerm -bldappl-> BF().
  
signature
  native operators
    importTerm : IC * String -> T

rules // import term

  IC ic |- ImportTerm(p) --> S(t)
  where
    importTerm(ic, p) => t.
