module
  stratego/core/strategies

imports
  shared 
  terms
  aterm
  stratego-signatures

signature 
  internal-constructors 
    lookup : E * String -> Term

rules // environment manipulation

  lookup(env, x) --> S(at)
  where
    env[x] => t,
    asATerm(t) => at // only required for type checking
  
  lookup(env, x) --> F()
  where all-fail

signature
  internal-constructors
    m : PreTerm -> Term
    ml: List(Term) -> Term

rules // match dispatch annotations

  T t |- Match(NoAnnoList(mp)) --> v
  where
    T t |- m(mp) --> v

  T t |- Match(Anno(mp, ma)) --> S(t)
  where
    T t |- m(mp) --> S(t'),
    getAnnotations[t]() => aa,
    T aa |- m(ma) --> S(t'')

  T t |- Match(Var(x)) --> S(t)
  where
    T t |- m(Var(x)) --> S(t')

  T t |- Match(x) --> F()
  where
    all-fail

rules // actual matching

  T t |- m(Wld()) --> S(t)

  T t |- m(Int(i)) --> S(t)
  where
    isATermInt(t) => True(),
    asATermInt(t) => aint,
    intValue[aint]() => i',
    i == i'
  
  T t |- m(Str(s)) --> S(t)
  where
    isATermString(t) => True(),
    asATermString(t) => astr,
    stringValue[astr]() => s',
    s == s'
  
  // match against unbound variable
  T t |- (m(Var(x)), E env) --> (S(t), E { x |--> t, env })
  where
    lookup(env, x) --> F()
  
  // match against bound variable
  T t |- (m(Var(x)), E env) --> S(t)
  where
    lookup(env, x) --> S(t'),
    t == t'

  // compound as with unbound variable
  T t |- (m(As(Var(x), p)), E env) --> (S(t), E { x |--> t, env'})
  where
    lookup(env, x) --> F(),
    T t |- (m(p), E env) --> (S(t'), E env')
  
  // compound as with bound variable
  T t |- (m(As(Var(x), p)), E env) --> (S(t), E env')
  where
    lookup(env, x) --> S(t'),
    t == t',
    T t |- (m(p), E env) --> (S(t''), E env')
  
  // match application
  T t |- (m(Op(c, pts)), E env, D def) --> (S(t), E env', D def)
  where
    isATermAppl(t) => True(),
    asATermAppl(t) => aappl,
    getConstructor[aappl]() => aconstr,
    getName[aconstr]() => c',
    c == c',
    getAllSubterms[aappl]() => aats,
    T aats |- (ml(pts), E env, D def) --> (S(aats'), E env', D def')

  // match explode
  T t, TF tf |- m(Explode(ct, ts)) --> S(t)
  where
    isATermAppl(t) => True(),
    asATermAppl(t) => aappl,
    getConstructor[aappl]() => aconstr,
    getName[aconstr]() => c',
    makeString[tf](c') => ac',
    T ac' |- Match(ct) --> S(ct'),
    getAllSubterms[aappl]() => aats,
    T aats |- Match(ts) --> S(aats')
    
  // match an empty list (not a Nil())
  T t |- ml([]) --> S(t)
  where
    isATermList(t) => True(),
    asATermList(t) => alist,
    isEmpty[alist](t) => True()
  
  // match a non-empty list (not a Cons(_, _))
  T t |- ml([p | ps]) --> S(t)
  where
    isATermList(t) => True(),
    asATermList(t) => alist,
    isEmpty[alist](t) => False(),
    head[alist](t) => th,
    T th |- Match(p) --> S(t'),
    tail[alist](t) => tl,
    T tl |- ml(ps) --> S(t'')
  
  T t |- ml(l) --> F()
  where all-fail

signature
  internal-constructors
    b : PreTerm -> Term
    bl : List(Term) -> Term

rules // build

  TF tf |- Build(Anno(t, as)) --> S(aterm)
  where
    b(t) --> S(at),
    b(as) --> S(aas),
    annotateTerm[tf](at, aas) => aterm
  
  Build(Var(x)) --> S(aterm)
  where
    b(Var(x)) --> S(aterm)

  (b(Var(x)), E env) --> v
  where
    lookup(env, x) --> v // may be F() when x is unbound
      
  TF tf |- b(Int(i)) --> S(aint)
  where
    makeInt[tf](i) => aint
  
  TF tf |- b(Str(s)) --> S(astr)
  where
    makeString[tf](s) => astr
   
  TF tf |- b(Op(c, ts)) --> S(aappl)
  where
    length(ts) => tslen,
    makeConstructor[tf](c, tslen) => constr,
    bl(ts) --> S(ats),
    makeAppl[tf](c, ats) => aappl // maybe replace with higher level makeAppl(String, List(Term))
    
  TF tf |- b(Explode(ct, ts)) --> S(t)
  where
    Build(ct) --> S(ac), // constructor name
    isATermString(ac) => True(),
    stringValue[asATermString(ac)]() => c,  
    Build(ts) => S(ats), // subterms
    isATermList(ats) => True(),
    toNativeList(asATermList(ats)) => ts',
    length(ts') => tslen,
    makeConstructor[tf](c, tslen) => constr,
    makeAppl[tf](constr, ts') => t
  
  TF tf |- bl([]) --> S(anil)
  where
    makeList[tf]([]) => anil
  
  TF tf |- bl([t | ts]) --> S(alist)
  where
    Build(t) --> S(at),
    bl(ts) --> S(ats),
    makeListCons[tf](at, ats) => alist

rules // scope 

  Scope([x], s) --> t'
  where
    s --> t'
  
  (Scope([x | xs], s), E env) --> (v, E {x |--> oldx, env'})
  where
    lookup(env, x) => oldx, // backup current value
    (Scope(xs, s), E env) --> (v, E env')

rules // identity and failure

  T t |- Id() --> S(t)
  
  Fail() --> F()
  
rules // proceed

  // ProceedT(s*, t*) ?
  
  // ProceedNoArgs() ?

rules // sequential composition
  
  Seq(s1, s2) --> v
  where s1 --> S(t'), T t' |- s2 --> v 
        
  Seq(s1, s2) --> F()
  where s1 --> F()
                   
rules // guarded choice   
        
  GuardedLChoice(s1, s2, s3) --> v
  where s1 --> S(t), T t |- s2 --> v
                
  GuardedLChoice(s1, s2, s3) --> v
  where s1 --> F(), s3 --> v

rules // left choice (explicit)

  LChoice(s1, s2) --> S(t')
  where s1 --> S(t')
  
  LChoice(s1, s2) --> v
  where s1 --> F(), s2 --> v

signature
  internal-constructors
    map : Strategy -> Strategy

rules // term traversal: all

  T t, TF tf |- All(s) --> S(t')
  where  
    isATermAppl(t) => True(),
    asATermAppl(t) => at,
    getConstructor[at]() => ac,
    getAllSubterms[at]() => ats,
    T ats |- map(s)--> S(ats'),
    makeAppl[tf](ac, ats') => t' // annotations?

  T t |- All(s) --> F()
  where all-fail

  T t |- map(s) --> S([])
  where
    isATermList[t]() => True(),
    isEmpty[t] => True()
  
  T t |- map(s) --> S(ts'')
  where
    isATermList[t]() => True(),
    isEmpty[t] => False(),
    head[t] => th,
    tail[t] => ts,
    T th |- s --> S(th'),
    T ts |- map(s) --> S(ts'),
    makeListCons(th', ts') => ts''

  T t |- map(s) --> F()
  where all-fail

signature
  internal-constructors
    first : Strategy -> Strategy

rules // term traversal: one
  
  T t |- One(s) --> S(t')
  where
    isATermAppl(t) => True(),
    asATermAppl(t) => at,
    getConstructor[at]() => ac,
    getAllSubterms[at]() => ats,
    T ats |- first(s) --> S(ats'),
    makeAppl[tf](ac, ats') => t' // annotations?
     
  T t |- One(s) --> F()
  where all-fail
  
  T t |- first(s) --> F()
  where
    t => [] // change to aterm ops
  
  T t |- first(s) --> S([te' | tes'])  // change to aterm ops
  where
    t => [te | tes],  // change to aterm ops
    T te |- s --> S(te')

  T t |- first(s) --> S([te' | tes'])  // change to aterm ops
  where
    t => [te | tes],  // change to aterm ops
    T te  |- s --> F(),
    T tes |- first(s) --> S(tes')
  
  T t |- first(s) --> F()
  where all-fail
    
rules // strategy definitions

  // top-level definitions are added to global definition environment
  
  defs([]) --> {}
  
  defs([SDefT(sname, ss, ts, s) | ds]) --> { sname |--> SDefT(sname, ss, ts, s), defs }
  where 
    defs(ds) --> defs
  
  // future: consider doing proper closures

signature
  internal-constructors
    closure: Term * E -> Term
    bind: List(String) * List(String) * Map -> Term

rules // calls
  
  D defs |- (CallT(SVar(sname), ass, ats), E env) --> (v, E env')
  where    
    bl(ats) --> ats', // evaluate term argument expressions
    defs[sname] => SDefT(sname, ss, ts, s),   
    D { ss |*-> ass, defs } |- (s, E {ts |*-> ats', env}) --> (v, E env')
    // todo: restore original values of ts in env'
      
rules // let - in - end

  Let([], s) --> v
  where s --> v
  
  D defs |- Let([SDefT(sname, ss, ts, s) | sdefs], s) --> v
  where
    D { sname |--> SDefT(sname, ss, ts, s), defs } |- Let(sdefs, s) --> v

rules // primitives

  Prim(name, ts) --> v
  where primitive(name, ts) --> v // implement in Java
  
rules // dynamic call

  CallDynamic(t, sts, tts) --> v
  where Build(t) --> f,
        CallT(f, sts, tts) --> v
      
    
    




