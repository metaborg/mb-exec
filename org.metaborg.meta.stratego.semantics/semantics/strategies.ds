module
  strategies

imports
  base
  shared
  aterm
  stratego-signatures

signature
  internal-constructors 
    lookup : E * String -> Term

rules // environment manipulation

  // TODO rewrite to equation ?
  
  lookup(env, x) --> v
  where
    env[x] => t,
    t != F(),
    S(t) => v
  
  lookup(env, x) --> v
  where
    all-fail,
    F() => v

rules // match dispatch annotations

  T t, TF tf |- (Match(NoAnnoList(mp)), E env) --> (v, E env)
  where
    T t, TF tf |- m(mp) --> v

  T t, TF tf |- Match(Anno(mp, ma)) --> v
  where
    T t, TF tf |- m(mp) --> S(t'),
    getAnnotations[t]() => aa,
    T aa, TF tf |- m(ma) --> S(t''),
    S(t) => v

  T t, TF tf |- Match(Var(x)) --> v
  where
    T t, TF tf |- m(Var(x)) --> S(t'),
    S(t) => v

  T t, TF tf |- Match(x) --> v
  where
    all-fail,
    F() => v

signature
  internal-constructors
    m : PreTerm -> Term
    ml: List(STerm) -> Term
    
rules // actual matching

  T t, TF tf |- m(Wld()) --> v
  where
    S(t) => v

  T t, TF tf |- m(Int(i)) --> v
  where
    isATermInt(t) == true,
    asATermInt(t) => aint,
    intValue[aint]() => i',
    i == i',
    S(t) => v
  
  T t, TF tf |- m(Str(s)) --> v
  where
    isATermString(t) == true,
    asATermString(t) => astr,
    stringValue[astr]() => s',
    s == s',
    S(t) => v

  // match against unbound variable
  T t, TF tf |- (m(Var(x)), E env) --> (v, E { x |--> t, env })
  where
    lookup(env, x) --> F(),
    S(t) => v

  // match against bound variable
  T t, TF tf |- (m(Var(x)), E env) --> v
  where
    lookup(env, x) --> S(t'),
    t == t',
    S(t) => v

  // compound as with unbound variable
  T t, TF tf |- (m(As(Var(x), p)), E env) --> (S(t), E { x |--> t, env'})
  where
    lookup(env, x) --> F(),
    T t , TF tf |- (m(p), E env) --> (S(t'), E env')
  
  // compound as with bound variable
  T t, TF tf |- (m(As(Var(x), p)), E env) --> (S(t), E env')
  where
    lookup(env, x) --> S(t'),
    t == t',
    T t, TF tf |- (m(p), E env) --> (S(t''), E env')
  
  // match application
  T t, TF tf |- (m(Op(c, pts)), E env) --> (S(t), E env')
  where
    isATermAppl(t) == true,
    asATermAppl(t) => aappl,
    getConstructor[aappl]() => aconstr,
    getName[aconstr]() => c',
    c == c',
    getAllSubterms(aappl) => subterms,
    makeList(tf, subterms) => asubterms,
    T asubterms, TF tf |- (ml(pts), E env) --> (S(aats'), E env')

  // match explode
  T t, TF tf |- m(Explode(ct, ts)) --> S(t)
  where
    isATermAppl(t) == true,
    asATermAppl(t) => aappl,
    getConstructor[aappl]() => aconstr,
    getName[aconstr]() => c',
    makeString[tf](c') => ac',
    T ac', TF tf |- Match(ct) --> S(ct'),
    getAllSubterms(aappl) => subterms,
    makeList(tf, subterms) => asubterms, 
    T asubterms, TF tf |- Match(ts) --> S(aats')
    
  // match failure
  m(dc) --> F()
  where
    all-fail
    
  // match an empty list (not a Nil())
  T t, TF tf |- ml([]) --> S(t)
  where
    isATermList(t) == true,
    asATermList(t) => alist,
    isEmpty[alist]() == true
  
  // match a non-empty list (not a Cons(_, _))
  T t, TF tf |- ml([p | ps]) --> S(t)
  where
    isATermList(t) == true,
    asATermList(t) => alist,
    isEmpty[alist]() == false,
    head[alist]() => th,
    T th, TF tf |- Match(p) --> S(t'),
    tail[alist]() => tl,
    T tl, TF tf |- ml(ps) --> S(t'')
  
  ml(l) --> F()
  where
    all-fail

signature
  internal-constructors
    b : PreTerm -> Term
    bl : List(STerm) -> Term

rules // build

  T ct, TF tf |- Build(Anno(t, as)) --> S(aterm)
  where
    b(t) --> S(at),
    b(as) --> S(aas),
    isATermList(aas) == true,
    asATermList(aas) => aas',
    annotateTerm[tf](at, aas') => aterm
  
  Build(Var(x)) --> v
  where
    b(Var(x)) --> v,
    v => S(aterm)

  (b(Var(x)), E env) --> (v, E env)
  where
    lookup(env, x) --> v,
    v => S(aterm) // force lookup of x to be a success
      
  T t, TF tf |- b(Int(i)) --> v
  where
    makeInt[tf](i) => aint,
    S(aint) => v
  
  T t, TF tf |- b(Str(s)) --> v
  where
    makeString[tf](s) => astr,
    S(astr) => v
   
  T t, TF tf |- b(Op(c, ts)) --> v
  where
    length(ts) => tslen,
    makeConstructor[tf](c, tslen) => constr,
    bl(ts) --> S(ats),
    isATermList(ats) == true,
    asATermList(ats) => ats',
    toNativeList(ats') => ts',
    makeAppl(tf, constr, ts') => aappl, // maybe replace with higher level makeAppl(String, List(Term))
    S(aappl) => v
    
  T cat, TF tf |- b(Explode(ct, ts)) --> v
  where
    Build(ct) --> S(ac), // constructor name
    isATermString(ac) == true,
    asATermString(ac) => atermstr,
    stringValue[atermstr]() => c,  
    Build(ts) => S(ats), // subterms
    isATermList(ats) == true,
    asATermList(ats) => ats',
    size[ats']() => tslen,
    makeConstructor[tf](c, tslen) => constr,
    toNativeList(ats') => ts',
    makeAppl(tf, constr, ts') => t,
    S(t) => v
    
  T t, TF tf |- bl([]) --> v
  where
    makeList(tf, []) => anil,
    S(anil) => v
  
  T ct, TF tf |- bl([t | ts]) --> v
  where
    Build(t) --> S(at),
    bl(ts) --> S(ats),
    isATermList(ats) == true,
    asATermList(ats) => ats',
    makeListCons[tf](at, ats') => alist,
    S(alist) => v

rules // scope 
  
  Scope([], s) --> t'
  where
    s --> t'
  
  (Scope([x | xs], s), E env) --> (v, E {x |--> oldx, env'})
  where
    lookup(env, x) => oldx,
    (Scope(xs, s), E {x |--> F(), env}) --> (v, E env')

rules // identity and failure

  T t, TF tf |- Id() --> S(t)
  
  Fail() --> F()
  
rules // proceed

  // ProceedT(s*, t*) ?
  
  // ProceedNoArgs() ?

rules // sequential composition
  
  T t , TF tf |- Seq(s1, s2) --> v2
  where
    s1 --> v1,
    v1 => S(t'),
    T t', TF tf |- s2 --> v2
        
  Seq(s1, s2) --> v1
  where
    s1 --> v1,
    v1 => F()
                    
rules // guarded choice   
        
  GuardedLChoice(s1, s2, s3) --> v
  where
    s1 --> S(t),
    T t |- s2 --> v
                
  GuardedLChoice(s1, s2, s3) --> v
  where
    s1 --> F(),
    s3 --> v

rules // left choice

  LChoice(s1, s2) --> v1
  where
    s1 --> v1,
    v1 => S(t)
  
  LChoice(s1, s2) --> v2
  where
    s1 --> v1,
    v1 => F(),
    s2 --> v2

signature
  internal-constructors
    map : Strategy -> Strategy

rules // term traversal: all

/*
  // <all> 42
  T t, TF tf |- All(s) --> v
  where
    isATermInt(t) == true,
    F() => v
  
  // <all> "string"
  T t, TF tf |- All(s) --> v
  where
    isATermString(t) == true,
    F() => v
  
  // TODO case for <all> "4.5"
  
*/
  
  // <all> (tup1, tup2, ...)
  T t, TF tf |- All(s) --> v
  where
    isATermTuple(t) == true,
    getAllSubterms(t) => ts,
    makeList(tf, ts) => ats,
    T ats, TF tf |- map(s) --> v,
    v => S(t')

  T t, TF tf |- All(s) --> v
  where  
    isATermAppl(t) == true,
    asATermAppl(t) => at,
    getConstructor[at]() => ac,
    getAllSubterms(at) => ts,
    makeList(tf, ts) => ats,
    T ats, TF tf |- map(s) --> S(ats'),
    isATermList(ats') == true,
    asATermList(ats') => ats'',
    toNativeList(ats'') => ts',
    makeAppl(tf, ac, ts') => t',
    annotateTerm[tf](t', getAnnotations[t]()) => t'', // copy over the old annotations,
    S(t'') => v

  All(s) --> F()
  where
    all-fail

  T t, TF tf |- map(s) --> v
  where
    isATermList(t) == true,
    asATermList(t) => lt,
    isEmpty[lt]() == true,
    S(t) => v
  
  T t, TF tf |- map(s) --> v
  where
    isATermList(t) == true,
    asATermList(t) => lt,
    isEmpty[lt]() == false,
    head[lt]() => th,
    tail[lt]() => ts,
    T th, TF tf |- s --> S(th'),
    T ts, TF tf |- map(s) --> S(ts'),
    isATermList(ts') == true,
    asATermList(ts') => ats,
    makeListCons[tf](th', ats) => ts'',
    S(ts'') => v

  map(s) --> F()
  where
    all-fail

signature
  internal-constructors
    first : Strategy -> Strategy

rules // term traversal: one
  
/*
  // <one> 42  
  T t, TF tf |- One(s) --> v
  where
    isATermInt(t) == true,
    F() => v

  // TODO add case for <one> 42.5
  
  // <one> "string"
  T t, TF tf |- One(s) --> v
  where
    isATermString(t) == true,
    F() => v
*/

  // <one> (tup1, tup2, ...)
  T t, TF tf |- One(s) --> v
  where
    isATermTuple(t) == true,
    getAllSubterms(t) => ts,
    makeList(tf, ts) => ats,
    T ats, TF tf |- first(s) --> S(t'),
    S(t') => v
  
  T t, TF tf |- One(s) --> v
  where
    isATermList(t) == true,
    getAllSubterms(t) => ts,
    makeList(tf, ts) => ats,
    T ats, TF tf |- first(s) --> v,
    v => S(t')
  
  T t, TF tf |- One(s) --> v
  where
    isATermAppl(t) == true,
    asATermAppl(t) => at,
    getConstructor[at]() => ac,
    getAllSubterms(at) => ts,
    makeList(tf, ts) => ats,
    T ats, TF tf |- first(s) --> S(ats'),
    isATermList(ats') == true,
    makeAppl(tf, ac, ts) => t',
    annotateTerm[tf](t', getAnnotations[t]()) => t'', // copy over annotations
    S(t'') => v
  
  One(s) --> F()
  where all-fail
  
  // empty candidate list
  T t, TF tf |- first(s) --> v
  where
    isATermList(t) == true,
    asATermList(t) => lt,
    isEmpty[lt]() == true,
    F() => v
  
  // non-empty head success
  T t, TF tf |- first(s) --> v
  where
    isATermList(t) == true,
    asATermList(t) => lt,
    isEmpty[lt]() == false,
    head[lt]() => th,
    tail[lt]() => tl,
    T th, TF tf |- s --> v1,
    v1 => S(th'),
    makeListCons[tf](th', tl) => t',
    S(t') => v
  
  // non-empty head success
  T t, TF tf |- first(s) --> v
  where
    isATermList(t) == true,
    asATermList(t) => lt,
    isEmpty[lt]() == false,
    head[lt]() => th,
    tail[lt]() => tl,
    T th, TF tf |- s --> v1,
    v1 => F(),
    T tl, TF tf |- first(s) --> S(tl'),
    isATermList(tl') == true,
    asATermList(tl') => tl'',
    makeListCons[tf](th, asATermList(tl')) => t',
    S(t') => v
  
  first(s) --> F()
  where all-fail
  
// signature
//   internal-constructors
//     specDefs : Module -> D
//     defs : List(Def) -> D
// 
// // rules // strategy definitions
// //   
// //   // TODO rewrite to equations
// //   // TODO do something with the signatures (store them)
// //   
// //   specDefs(Specification([sigs, Strategies(ss)])) -defs-> defs(ss)
// // 
// //   // top-level definitions are added to global definition environment
// //   defs([]) -defs-> {}
// //   
// //   defs([SDefT(sname, ss, ts, s) | ds]) -defs-> { sname |--> SDefT(sname, ss, ts, s), defs }
// //   where 
// //     defs(ds) => defs
// //   
// //   // future: consider doing proper closures
// 
// signature
//   internal-constructors // axioms
//     bindASVars: List(Typedid) * List(Strategy) -> D
//     bindASVar: Typedid * Strategy -> D
//       
//     
// rules // calls
// 
//   D defs |- (CallT(SVar(sname), asargs, atargs), E env) --> (v, E env')
//   where
//     bl(atargs) --> atargs', // evaluate term argument expressions
//     defs[sname] => SDefT(sname', fsargs, ftargs, s),
//     sname == sname', // sanity check
//     bindASVars(fsargs, asargs) => defs',
//     D {defs', defs} |- (s, E {ftargs |*-> atargs', env}) --> (v, E env')
//   
//   // TODO reduction for CallT calling a strategy in the manual interpreter or in compiled code
//   
//   // TODO rewrite to equations
//   
//   // bindASVars([], []) == {}
//   // should rewrite to:
//   //    bindASVars([], []) --axiom_bindASVars_2> {}
//   
//   // bindASVars([tid | tidxs], [s | sxs]) == {bindASVar(tid, s), bindASVars(tidxs, sxs)}
//   
//   // bindASVar(VarDec(x, t), s) == { x |--> SDefT(x, [], [], s) }
//   // should rewrite to:
//   //    bindASVar(VarDEc(x,))
//   
// rules // let - in - end
// 
//   Let([], s) --> v
//   where
//     s --> v
//   
//   D defs |- Let([SDefT(sname, ss, ts, s1) | sdefs], s2) --> v
//   where
//     D { sname |--> SDefT(sname, ss, ts, s1), defs } |- Let(sdefs, s2) --> v
// 
// signature
//   internal-constructors
//     primitive : String * List(Strategy) * TLIST -> Term
// 
// rules // primitives
// 
//   PrimT(name, asargs, atargs) --> v
//   where
//     bl(atargs) --> S(ats),
//     isATermList(ats) => True(),
//     asATermList(ats) => ats',
//     primitive(name, asargs, ats') --> v // implement in Java
//   
// rules // dynamic call
//   
//   CallDynamic(t, sts, tts) --> v
//   where
//     Build(t) --> S(asname),
//     isATermString(asname) => True(),
//     asATermString(asname) => asname',
//     stringValue[asname']() => sname,
//     CallT(SVar(sname), sts, tts) --> v
//       
