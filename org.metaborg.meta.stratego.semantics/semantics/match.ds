module match

imports
  base
  stratego-signatures
  shared
  aterm
  environment

signature
  sorts
    Matcher
    
  internal-constructors
    m : PreTerm -> Matcher
    ml: List(STerm) -> Matcher

  arrows
    Matcher -ma-> Value

rules // match dispatch annotations

  Match(NoAnnoList(mp)) --> v
  where
    m(mp) -ma-> v

  T t |- Match(Anno(mp, ma)) --> v
  where
    T t  |- m(mp) -ma-> S(t'),
    getAnnotations[t]() => aa,
    T aa |- m(ma) -ma-> S(t''),
    S(t) => v

  T t |- Match(Var(x)) --> v
  where
    T t |- m(Var(x)) -ma-> S(t'),
    S(t) => v

  Match(x) --> v
  where
    all-fail,
    F() => v

rules // actual matching

  T t |- m(Wld()) -ma-> v
  where
    S(t) => v

  T t |- m(Int(stringI)) -ma-> v
  where
    isATermInt(t) == true,
    asATermInt(t) => aint,
    intValue[aint]() => i',
    parseInt(stringI) => i,
    i == i',
    S(t) => v
  
  T t |- m(Str(s)) -ma-> v
  where
    isATermString(t) == true,
    asATermString(t) => astr,
    stringValue[astr]() => s',
    s == s',
    S(t) => v

  // match against unbound variable
  T t |- (m(Var(x)), E env) -ma-> (v, E env')
  where
    E env |- lookup(x) -look-> xv,
    xv => F(),
    S(t) => v,
    { x |--> v, env } => env'

  // match against bound variable
  T t |- (m(Var(x)), E env) -ma-> (v, E env)
  where
    E env |- lookup(x) -look-> xv,
    xv => S(t'),
    t == t',
    S(t) => v

  // compound As with unbound variable. The variable is only bound if the match succeeds.
  T t |- (m(As(Var(x), p)), E env) -ma-> (S(t), E { x |--> t, env'})
  where
    E env |- lookup(x) -look-> F(),
    T t |- (m(p), E env) -ma-> (S(t'), E env')
  
  // compound As with bound variable
  T t |- (m(As(Var(x), p)), E env) -ma-> (S(t), E env')
  where
    E env |- lookup(x) -look-> S(xt),
    t == xt,
    T t |- (m(p), E env) -ma-> (S(t''), E env')
  
  // match application
  T t, TF tf |- (m(Op(c, pts)), E env) -ma-> (S(t), E env')
  where
    isATermAppl(t) == true,
    asATermAppl(t) => aappl,
    getConstructor[aappl]() => aconstr,
    getName[aconstr]() => c',
    c == c',
    getAllSubterms[aappl]() => subterms,
    makeList[tf](subterms) => asubterms,
    T asubterms |- (ml(pts), E env) -ma-> (S(aats'), E env')

  // match explode
  T t, TF tf |- m(Explode(ct, ts)) -ma-> S(t)
  where
    isATermAppl(t) == true,
    asATermAppl(t) => aappl,
    getConstructor[aappl]() => aconstr,
    getName[aconstr]() => c',
    makeString[tf](c') => ac',
    T ac' |- Match(ct) --> S(ct'),
    getAllSubterms[aappl]() => subterms,
    makeList[tf](subterms) => asubterms,
    T asubterms |- Match(ts) --> S(aats')
    
  // match failure
  m(dc) -ma-> F()
  where
    all-fail
    
  // match an empty list
  T t |- ml([]) -ma-> S(t)
  where
    isATermList(t) == true,
    asATermList(t) => alist,
    isEmpty[alist]() == true
  
  // match a non-empty list
  T t |- ml([p | ps]) -ma-> S(t)
  where
    isATermList(t) == true,
    asATermList(t) => alist,
    isEmpty[alist]() == false,
    head[alist]() => th,
    T th |- Match(p) --> S(t'),
    tail[alist]() => tl,
    T tl |- ml(ps) -ma-> S(t'')
  
  ml(l) -ma-> F()
  where
    all-fail
