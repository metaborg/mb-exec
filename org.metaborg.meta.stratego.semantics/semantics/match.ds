module match

imports
  base
  stratego-signatures
  shared
  aterm
  util

rules // match dispatch annotations

  Match(NoAnnoList(mp)) --> v
  where
    m(mp) --> v

  T t |- Match(Anno(mp, ma)) --> v
  where
    T t  |- m(mp) --> S(t'),
    getAnnotations[t]() => aa,
    T aa |- m(ma) --> S(t''),
    S(t) => v

  T t |- Match(Var(x)) --> v
  where
    T t |- m(Var(x)) --> S(t'),
    S(t) => v

  Match(x) --> v
  where
    all-fail,
    F() => v

signature
  internal-constructors
    m : PreTerm -> Term
    ml: List(STerm) -> Term
    
rules // actual matching

  T t |- m(Wld()) --> v
  where
    S(t) => v

  T t |- m(Int(i)) --> v
  where
    isATermInt(t) == true,
    asATermInt(t) => aint,
    intValue[aint]() => i',
    i == i',
    S(t) => v
  
  T t |- m(Str(s)) --> v
  where
    isATermString(t) == true,
    asATermString(t) => astr,
    stringValue[astr]() => s',
    s == s',
    S(t) => v

  // match against unbound variable
  T t |- (m(Var(x)), E env) --> (v, E { x |--> t, env })
  where
    lookup(env, x) --> F(),
    S(t) => v

  // match against bound variable
  T t |- (m(Var(x)), E env) --> (v, E env)
  where
    lookup(env, x) --> S(t'),
    t == t',
    S(t) => v

  // compound As with unbound variable. The variable is only bound if the match succeeds.
  T t |- (m(As(Var(x), p)), E env) --> (S(t), E { x |--> t, env'})
  where
    lookup(env, x) --> F(),
    T t |- (m(p), E env) --> (S(t'), E env')
  
  // compound As with bound variable
  T t |- (m(As(Var(x), p)), E env) --> (S(t), E env')
  where
    lookup(env, x) --> S(xt),
    t == xt, // VV: there might be an issue here since TermEq does an t.equals(xt) check and not t == xt.
    T t |- (m(p), E env) --> (S(t''), E env')
  
  // match application
  T t, TF tf |- (m(Op(c, pts)), E env) --> (S(t), E env')
  where
    isATermAppl(t) == true,
    asATermAppl(t) => aappl,
    getConstructor[aappl]() => aconstr,
    getName[aconstr]() => c',
    c == c',
    getAllSubterms(aappl) => subterms,
    makeList(tf, subterms) => asubterms,
    T asubterms |- (ml(pts), E env) --> (S(aats'), E env')

  // match explode
  T t, TF tf |- m(Explode(ct, ts)) --> S(t)
  where
    isATermAppl(t) == true,
    asATermAppl(t) => aappl,
    getConstructor[aappl]() => aconstr,
    getName[aconstr]() => c',
    makeString[tf](c') => ac',
    T ac' |- Match(ct) --> S(ct'),
    getAllSubterms(aappl) => subterms,
    makeList(tf, subterms) => asubterms,
    T asubterms |- Match(ts) --> S(aats')
    
  // match failure
  m(dc) --> F()
  where
    all-fail
    
  // match an empty list
  T t |- ml([]) --> S(t)
  where
    isATermList(t) == true,
    asATermList(t) => alist,
    isEmpty[alist]() == true
  
  // match a non-empty list
  T t |- ml([p | ps]) --> S(t)
  where
    isATermList(t) == true,
    asATermList(t) => alist,
    isEmpty[alist]() == false,
    head[alist]() => th,
    T th |- Match(p) --> S(t'),
    tail[alist]() => tl,
    T tl |- ml(ps) --> S(t'')
  
  ml(l) --> F()
  where
    all-fail