module match

imports
  semantics/stratego-signatures
  semantics/shared
  semantics/aterm
  semantics/state

signature
  sorts
    Matcher

  arrows
    STerm -ma-> Value
    STerm -malst-> Value
    STerm -maappl-> Value 
    List(STerm) -ma-> Value

rules // match dispatch annotations

  T t |- Match(Wld()) --> S(t).

  Match(NoAnnoList(mp)) --> v
  where
    mp -ma-> v.

  T t |- Match(Anno(mp, ma)) --> S(t)
  where
    T t  |- mp -ma-> S(_);
    getAnnotations[t]() => aa;
    T aa |- ma -ma-> S(_).

  T t |- Match(var@Var(_)) --> S(t)
  where
    T t |- var -ma-> S(_).

  T t |- Match(As(var, p)) --> v
  where
    T t |- As(var, p) -ma-> v.

  Match(_) --> F()
  where
    all-fail.

rules // actual matching

  T t |- Wld() -ma-> S(t).

  T t |- Int(stringI) -ma-> S(t)
  where
    t <: TINT;
    intValue[t]() => i';
    parseInt(stringI) => i;
    i == i'.
  
  T t |- Real(stringR) -ma-> S(t)
  where
    t <: TREAL;
    realValue[t]() => r';
    parseReal(stringR) => r;
    r == r'.
  
  T t |- Str(s) -ma-> S(t)
  where
    t <: TSTR;
    stringValue[t]() => s';
    s == s'.

  // match against unbound variable
  T t |- Var(x) -ma-> v
  where
    VLookup(x) -vlook-> F();
    S(t) => v;
    VUpdate(x, v) -vupdate-> _.

  // match against bound variable
  T t |- Var(x) -ma-> S(t)
  where
    VLookup(x) -vlook-> S(t');
    t == t'.

  // compound As with unbound variable. The variable is only bound if the match succeeds.
  T t |- As(Var(x), p) -ma-> S(t)
  where
    VLookup(x) -vlook-> F();
    Match(p) --> S(_);
    VUpdate(x, S(t)) -vupdate-> _.
  
  // compound As with bound variable
  T t |- As(Var(x), p) -ma-> S(t)
  where
    VLookup(x) -vlook-> S(xt);
    t == xt;
    T t |- Match(p) --> S(_).

  // Explode Appl
  T t, TF tf |- Explode(ct, ts) -ma-> S(t)
  where
    t <: TAPPL;
    makeString[tf](getName[getConstructor[t]()]()) => constr;
    T constr |- Match(ct) --> S(_);
    makeList[tf](getAllSubterms[t]()) => kids;
    T kids |- Match(ts) --> S(_).
  
  // Explode Int
  T t, TF tf |- Explode(ct, ts) -ma-> S(t)
  where
    t <: TINT;
    T t |- Match(ct) --> S(_);
    T makeNil(tf) |- Match(ts) --> S(_).
  
  // TODO Explode Real

  // Explode String
  T t, TF tf |- Explode(ct, ts) -ma-> S(t)
  where
    t <: TSTR;
    annotateTerm[tf](t, makeNil(tf)) => tnoanno;
    makeString[tf](toString[tnoanno]()) => constr;
    T constr |- Match(ct) --> S(_);
    T makeNil(tf) |- Match(ts) --> S(_).
  
  // Explode List
  T t, TF tf |- Explode(ct, ts) -ma-> S(t)
  where
    t <: TLIST;
    T makeNil(tf) |- Match(ct) --> S(_);
    T t |- Match(ts) --> S(_).
  
  // Explode Tuple
  T t, TF tf |- Explode(ct, ts) -ma-> S(t)
  where
    t <: TTUP;
    makeString[tf]("") => constr;
    T constr |- Match(ct) --> S(_);
    makeList[tf](getAllSubterms[t]()) => kids;
    T kids |- Match(ts) --> S(_).
  
  // match failure
  _ : STerm -ma-> F().
    
  // match an empty list
  T t |- [] : List(STerm) -ma-> S(t)
  where
    t <: TLIST;
    isEmpty[t]() == true.
  
  // match a non-empty list
  T t |- [p | ps] : List(STerm) -ma-> S(t)
  where
    t <: TLIST;
    isEmpty[t]() == false;
    T head[t]() |- Match(p) --> S(_);
    T tail[t]() |- ps -ma-> S(_).

  _ : List(STerm) -ma-> F()
  where all-fail.

rules

  op@Op("Nil", []) -ma-> mv
  where
    op -malst-> mv.
  
  op@Op("Nil", [_|_]) -ma-> mv
  where
    op -maappl-> mv.
  
  op@Op("Cons", pts) -ma-> mv
  where
    length(pts) == 2;
    op -malst-> mv.
  
  op@Op("Cons", pts) -ma-> mv
  where
    length(pts) != 2;
    op -maappl-> mv.
  
  T t |- Op(_, []) -malst-> S(t)
  where
    t <: TLIST;
    isEmpty[t]() == true.
  
  T t |- Op(_, [p1, p2]) -malst-> S(t)
  where
    t <: TLIST;
    isEmpty[t]() == false;
    T head[t]() |- Match(p1) --> S(_);
    T tail[t]() |- Match(p2) --> S(_).
  
  // FIX
  _ : STerm -malst-> F().
  
  T t, TF tf |- Op("", pts) -ma-> S(t)
  where
    t <: TTUP;
    getAllSubterms[t]() => elems;
    T makeList[tf](elems) |- pts -ma-> S(_).
  
  T t |- op@Op(c, _) -ma-> S(t)
  where
    c != "Nil";
    c != "Cons";
    c != "";
    op -maappl-> S(_).
     
  // match application
  T t, TF tf |- Op(c, pts) -maappl-> S(t)
  where
    t <: TAPPL;
    getConstructor[t]() => aconstr;
    getName[aconstr]() => c';
    c == c';
    getAllSubterms[t]() => subterms;
    makeList[tf](subterms) => asubterms;
    T asubterms |- pts -ma-> S(_).
  
  // FIX
  _ : STerm -maappl-> F().


