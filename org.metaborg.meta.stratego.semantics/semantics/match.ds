module match

imports
  base
  stratego-signatures
  shared
  aterm
  environment

signature
  sorts
    Matcher
    
  internal-constructors
    m : STerm -> Matcher
    ml: List(STerm) -> Matcher

  arrows
    Matcher -ma-> Value

rules // match dispatch annotations

  T t |- Match(Wld()) --> S(t)

  Match(NoAnnoList(mp)) --> v
  where
    m(mp) -ma-> v

  T t |- Match(Anno(mp, ma)) --> v
  where
    T t  |- m(mp) -ma-> S(t'),
    getAnnotations[t]() => aa,
    T aa |- m(ma) -ma-> S(t''),
    S(t) => v

  T t |- Match(Var(x)) --> v
  where
    T t |- m(Var(x)) -ma-> S(t'),
    S(t) => v

  T t |- Match(As(var, p)) --> v
  where
    T t |- m(As(var, p)) -ma-> v

  Match(x) --> v
  where
    all-fail,
    F() => v

rules // actual matching

  T t |- m(Wld()) -ma-> v
  where
    S(t) => v

  T t |- m(Int(stringI)) -ma-> v
  where
    isATermInt(t) == true,
    asATermInt(t) => aint,
    intValue[aint]() => i',
    parseInt(stringI) => i,
    i == i',
    S(t) => v
  
  T t |- m(Str(s)) -ma-> v
  where
    isATermString(t) == true,
    asATermString(t) => astr,
    stringValue[astr]() => s',
    s == s',
    S(t) => v

  // match against unbound variable
  T t |- (m(Var(x)), E env) -ma-> (v, E env')
  where
    E env |- lookup(x) -look-> xv,
    xv => F(),
    S(t) => v,
    { x |--> v, env } => env'

  // match against bound variable
  T t |- (m(Var(x)), E env) -ma-> (v, E env)
  where
    E env |- lookup(x) -look-> xv,
    xv => S(t'),
    t == t',
    S(t) => v

  // compound As with unbound variable. The variable is only bound if the match succeeds.
  T t |- (m(As(Var(x), p)), E env) -ma-> (S(t), E { x |--> S(t), env'})
  where
    E env |- lookup(x) -look-> lv,
    lv => F(),
    T t |- (Match(p), E env) --> (S(t'), E env')
  
  // compound As with bound variable
  T t |- (m(As(Var(x), p)), E env) -ma-> (S(t), E env')
  where
    E env |- lookup(x) -look-> lv,
    lv => S(xt),
    t == xt,
    T t |- (Match(p), E env) --> (S(t''), E env')

  // match explode
  T t, TF tf |- m(Explode(ct, ts)) -ma-> S(t)
  where
    isATermAppl(t) == true,
    asATermAppl(t) => aappl,
    getConstructor[aappl]() => aconstr,
    getName[aconstr]() => c',
    makeString[tf](c') => ac',
    T ac' |- Match(ct) --> S(ct'),
    getAllSubterms[aappl]() => subterms,
    makeList[tf](subterms) => asubterms,
    T asubterms |- Match(ts) --> S(aats')
    
  // match failure
  m(dc) -ma-> F()
  where
    all-fail
    
  // match an empty list
  T t |- ml([]) -ma-> S(t)
  where
    isATermList(t) == true,
    asATermList(t) => alist,
    isEmpty[alist]() == true
  
  // match a non-empty list
  T t |- ml([p | ps]) -ma-> S(t)
  where
    isATermList(t) == true,
    asATermList(t) => alist,
    isEmpty[alist]() == false,
    head[alist]() => th,
    T th |- Match(p) --> S(t'),
    tail[alist]() => tl,
    T tl |- ml(ps) -ma-> S(t'')
  
  ml(l) -ma-> F()
  where
    all-fail

signature
  internal-constructors
    mAppl : STerm -> Matcher
    mList : STerm -> Matcher

rules

  T t, TF tf |- m(Op(c, pts)) -ma-> mv
  where
    c == "Nil",
    length(pts) == 0,
    T t, TF tf |- mList(Op(c, pts)) -ma-> mv
  
  T t, TF tf |- m(Op(c, pts)) -ma-> mv
  where
    c == "Nil",
    length(pts) != 0,
    T t, TF tf |- mAppl(Op(c, pts)) -ma-> mv
  
  T t, TF tf |- m(Op(c, pts)) -ma-> mv
  where
    c == "Cons",
    length(pts) == 2,
    T t, TF tf |- mList(Op(c, pts)) -ma-> mv
  
  T t, TF tf |- m(Op(c, pts)) -ma-> mv
  where
    c == "Cons",
    length(pts) != 2,
    T t, TF tf |- mAppl(Op(c, pts)) -ma-> mv
  
  T t, TF tf |- mList(Op(c, pts)) -ma-> S(t)
  where
    pts => [],
    isATermList(t) == true,
    asATermList(t) => list,
    isEmpty[list]() == true
  
  T t, TF tf |- mList(Op(c, pts)) -ma-> S(t)
  where
    pts => [p1, p2],
    isATermList(t) == true,
    asATermList(t) => list,
    isEmpty[list]() == false,
    head[list]() => head,
    T head |- Match(p1) --> S(thead),
    tail[list]() => tail,
    T tail |- Match(p2) --> S(ttail)
  
  T t, TF tf |- mList(dc) -ma-> F()
  where all-fail
  
  T t, TF tf |- m(Op(c, pts)) -ma-> S(t)
  where
    c == "",
    isATermTuple(t) == true,
    asATermTuple(t) => tupl,
    getAllSubterms[tupl]() => elems,
    makeList[tf](elems) => elems',
    T elems' |- ml(pts) -ma-> S(tupl')
  
  T t, TF tf |- m(Op(c, pts)) -ma-> S(t)
  where
    c != "Nil",
    c != "Cons",
    c != "",
    T t, TF tf |- mAppl(Op(c, pts)) -ma-> S(t')
     
  // match application
  T t, TF tf |- mAppl(Op(c, pts)) -ma-> S(t)
  where
    isATermAppl(t) == true,
    asATermAppl(t) => aappl,
    getConstructor[aappl]() => aconstr,
    getName[aconstr]() => c',
    c == c',
    getAllSubterms[aappl]() => subterms,
    makeList[tf](subterms) => asubterms,
    T asubterms |- ml(pts) -ma-> S(aats')
  
  T t, TF tf |- mAppl(dc) -ma-> F()
  where all-fail


