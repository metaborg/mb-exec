module match

imports
  base
  stratego-signatures
  shared
  aterm
  state

signature
  internal-sorts
    Matcher
    
  internal-constructors
    m : STerm -> Matcher
    ml: List(STerm) -> Matcher

  arrows
    Matcher -ma-> Value

rules // match dispatch annotations

  T t |- Match(Wld()) --> S(t)

  Match(NoAnnoList(mp)) --> v
  where
    m(mp) -ma-> v

  T t |- Match(Anno(mp, ma)) --> v
  where
    T t  |- m(mp) -ma-> S(t'),
    getAnnotations[t]() => aa,
    T aa |- m(ma) -ma-> S(t''),
    S(t) => v

  T t |- Match(Var(x)) --> v
  where
    T t |- m(Var(x)) -ma-> S(t'),
    S(t) => v

  T t |- Match(As(var, p)) --> v
  where
    T t |- m(As(var, p)) -ma-> v

  Match(x) --> v
  where
    all-fail,
    F() => v

rules // actual matching

  T t |- m(Wld()) -ma-> v
  where
    S(t) => v

  T t |- m(Int(stringI)) -ma-> v
  where
    isATermInt(t) == true,
    asATermInt(t) => aint,
    intValue[aint]() => i',
    parseInt(stringI) => i,
    i == i',
    S(t) => v
  
  T t |- m(Real(stringR)) -ma-> v
  where
    isATermReal(t) == true,
    asATermReal(t) => areal,
    realValue[areal]() => r',
    parseReal(stringR) => r,
    r == r',
    S(t) => v
  
  T t |- m(Str(s)) -ma-> v
  where
    isATermString(t) == true,
    asATermString(t) => astr,
    stringValue[astr]() => s',
    s == s',
    S(t) => v

  // match against unbound variable
  VEnv e, T t |- m(Var(x)) -ma-> v
  where
    VLookup(e, x) -vlook-> VLookupResult(e', VBind(y, xv, e'')),
    xv => F(),
    S(t) => v,
    VUpdate(e', x, v) -vupdate-> e'''

  // match against bound variable
  VEnv e, T t |- m(Var(x)) -ma-> v
  where
    VLookup(e, x) -vlook-> VLookupResult(e', VBind(y, xv, e'')),
    xv => S(t'),
    t == t',
    S(t) => v

  // compound As with unbound variable. The variable is only bound if the match succeeds.
  VEnv e, T t |- m(As(Var(x), p)) -ma-> S(t)
  where
    VLookup(e, x) -vlook-> VLookupResult(e', VBind(y, lv, e'')),
    lv => F(),
    VEnv e, T t |- Match(p) --> S(t'),
    VUpdate(e', x, S(t)) -vupdate-> e'''
  
  // compound As with bound variable
  VEnv e, T t |- m(As(Var(x), p)) -ma-> S(t)
  where
    VLookup(e, x) -vlook-> VLookupResult(e', VBind(y, lv, e'')),
    lv => S(xt),
    t == xt,
    VEnv e, T t |- Match(p) --> S(t'')

  // Explode Appl
  T t, TF tf |- m(Explode(ct, ts)) -ma-> S(t)
  where
    isATermAppl(t) == true,
    asATermAppl(t) => appl,
    makeString[tf](getName[getConstructor[appl]()]()) => constr,
    T constr |- Match(ct) --> S(constr'),
    makeList[tf](getAllSubterms[appl]()) => kids,
    T kids |- Match(ts) --> S(kids')
  
  // Explode Int
  T t, TF tf |- m(Explode(ct, ts)) -ma-> S(t)
  where
    isATermInt(t) == true,
    t => constr,
    T constr |- Match(ct) --> S(constr'),
    makeNil(tf) => kids,
    T kids |- Match(ts) --> S(kids')
  
  // TODO Explode Real

  // Explode String
  T t, TF tf |- m(Explode(ct, ts)) -ma-> S(t)
  where
    isATermString(t) == true,
    annotateTerm[tf](t, makeNil(tf)) => tnoanno,
    makeString[tf](toString[tnoanno]()) => constr,
    T constr |- Match(ct) --> S(constr'),
    makeNil(tf) => kids,
    T kids |- Match(ts) --> S(kids')
  
  // Explode List
  T t, TF tf |- m(Explode(ct, ts)) -ma-> S(t)
  where
    isATermList(t) == true,
    makeNil(tf) => constr,
    T constr |- Match(ct) --> S(constr'),
    T t |- Match(ts) --> S(kids')
  
  // Explode Tuple
  T t, TF tf |- m(Explode(ct, ts)) -ma-> S(t)
  where
    isATermTuple(t) == true,
    makeString[tf]("") => constr,
    T constr |- Match(ct) --> S(constr'),
    makeList[tf](getAllSubterms[t]()) => kids,
    T kids |- Match(ts) --> S(kids')
    
  // match failure
  m(dc) -ma-> F()
  where
    all-fail
    
  // match an empty list
  T t |- ml([]) -ma-> S(t)
  where
    isATermList(t) == true,
    asATermList(t) => alist,
    isEmpty[alist]() == true
  
  // match a non-empty list
  T t |- ml([p | ps]) -ma-> S(t)
  where
    isATermList(t) == true,
    asATermList(t) => alist,
    isEmpty[alist]() == false,
    head[alist]() => th,
    T th |- Match(p) --> S(t'),
    tail[alist]() => tl,
    T tl |- ml(ps) -ma-> S(t'')
  
  ml(l) -ma-> F()
  where
    all-fail

signature
  internal-constructors
    mAppl : STerm -> Matcher
    mList : STerm -> Matcher

rules

  T t, TF tf |- m(Op(c, pts)) -ma-> mv
  where
    c == "Nil",
    length(pts) == 0,
    T t, TF tf |- mList(Op(c, pts)) -ma-> mv
  
  T t, TF tf |- m(Op(c, pts)) -ma-> mv
  where
    c == "Nil",
    length(pts) != 0,
    T t, TF tf |- mAppl(Op(c, pts)) -ma-> mv
  
  T t, TF tf |- m(Op(c, pts)) -ma-> mv
  where
    c == "Cons",
    length(pts) == 2,
    T t, TF tf |- mList(Op(c, pts)) -ma-> mv
  
  T t, TF tf |- m(Op(c, pts)) -ma-> mv
  where
    c == "Cons",
    length(pts) != 2,
    T t, TF tf |- mAppl(Op(c, pts)) -ma-> mv
  
  T t, TF tf |- mList(Op(c, pts)) -ma-> S(t)
  where
    pts => [],
    isATermList(t) == true,
    asATermList(t) => list,
    isEmpty[list]() == true
  
  T t, TF tf |- mList(Op(c, pts)) -ma-> S(t)
  where
    pts => [p1, p2],
    isATermList(t) == true,
    asATermList(t) => list,
    isEmpty[list]() == false,
    head[list]() => head,
    T head |- Match(p1) --> S(thead),
    tail[list]() => tail,
    T tail |- Match(p2) --> S(ttail)
  
  T t, TF tf |- mList(dc) -ma-> F()
  where all-fail
  
  T t, TF tf |- m(Op(c, pts)) -ma-> S(t)
  where
    c == "",
    isATermTuple(t) == true,
    asATermTuple(t) => tupl,
    getAllSubterms[tupl]() => elems,
    makeList[tf](elems) => elems',
    T elems' |- ml(pts) -ma-> S(tupl')
  
  T t, TF tf |- m(Op(c, pts)) -ma-> S(t)
  where
    c != "Nil",
    c != "Cons",
    c != "",
    T t, TF tf |- mAppl(Op(c, pts)) -ma-> S(t')
     
  // match application
  T t, TF tf |- mAppl(Op(c, pts)) -ma-> S(t)
  where
    isATermAppl(t) == true,
    asATermAppl(t) => aappl,
    getConstructor[aappl]() => aconstr,
    getName[aconstr]() => c',
    c == c',
    getAllSubterms[aappl]() => subterms,
    makeList[tf](subterms) => asubterms,
    T asubterms |- ml(pts) -ma-> S(aats')
  
  T t, TF tf |- mAppl(dc) -ma-> F()
  where all-fail


