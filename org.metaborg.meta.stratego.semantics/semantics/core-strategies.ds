module core-strategies
/*
 *
 * Specifications for:
 *   - id
 *   - fail
 *   - variable scoping
 *   - all
 *   - one
 *
*/
imports
  base
  stratego-signatures
  aterm
  shared
  state
  
rules // identity and failure

  T t |- Id() --> S(t)
  
  Fail() --> F()

rules // scope 
  
  Env e |- Scope([], s) --> t'
  where
    Env e |- s --> t'

  Env e |- Scope([x | xs], s)--> v
  where
    Push(e, x) -init-> e',
    Env e' |- Scope(xs, s) --> v

signature
  internal-sorts
    Mapper
    
  internal-constructors
    map : Strategy -> Mapper

  arrows
    Mapper -map-> Value
    
rules // term traversal: all

  // <all> 42
  T t |- All(s) --> S(t)
  where
    isATermInt(t) == true

  // TODO case for <all> "4.5"
  
  // <all> "string"
  T t |- All(s) --> S(t)
  where
    isATermString(t) == true
  
  // <all> (tup1, tup2, ...)
  T t, TF tf |- All(s) --> v
  where
    isATermTuple(t) == true,
    getAllSubterms[t]() => ts,
    makeList[tf](ts) => ats, // FIXME: extremely inefficient
    T ats |- map(s) -map-> S(ats'),
    isATermList(ats') == true,
    asATermList(ats') => ats'', 
    getAllSubterms[ats']() => ts',  // FIXME: extremely inefficient
    makeTuple[tf](ts') => t',
    annotateTerm[tf](t', getAnnotations[t]()) => t'', // copy over the old annotations
    S(t'') => v

  // <all> [a, b, c, ...]
  T t, TF tf |- All(s) --> v
  where
    isATermList(t) == true,
    asATermList(t) => tlist,
    T tlist |- map(s) -map-> v

  // <all> TNAME(t1, t2, ...)
  T t, TF tf |- All(s) --> v
  where  
    isATermAppl(t) == true,
    asATermAppl(t) => at,
    getConstructor[at]() => ac,
    getAllSubterms[at]() => ts,
    makeList[tf](ts) => ats, // FIXME: extremely inefficient
    T ats |- map(s) -map-> S(ats'),
    isATermList(ats') == true,
    asATermList(ats') => ats'',
    getAllSubterms[ats'']() => ts', // FIXME: extremely inefficient
    makeAppl[tf](ac, ts') => t',
    annotateTerm[tf](t', getAnnotations[t]()) => t'', // copy over the old annotations
    S(t'') => v

  All(s) --> F()
  where
    all-fail

  T t, TF tf |- map(s) -map-> v
  where
    isATermList(t) == true,
    asATermList(t) => lt,
    isEmpty[lt]() == true,
    S(t) => v
  
  T t, TF tf |- map(s) -map-> v
  where
    isATermList(t) == true,
    asATermList(t) => lt,
    isEmpty[lt]() == false,
    head[lt]() => th,
    tail[lt]() => ts,
    T th |- s --> S(th'),
    T ts |- map(s) -map-> S(ts'),
    isATermList(ts') == true,
    asATermList(ts') => ats,
    makeListCons[tf](th', ats) => ts'',
    S(ts'') => v

  map(s) -map-> F()
  where
    all-fail

signature
  internal-sorts
    Firster
    
  internal-constructors
    first : Strategy -> Firster
  
  arrows
    Firster -first-> Value

rules // term traversal: one
  
  // <one> (tup1, tup2, ...)
  T t, TF tf |- One(s) --> v
  where
    isATermTuple(t) == true,
    getAllSubterms[t]() => ts,
    makeList[tf](ts) => ats,
    T ats |- first(s) -first-> S(t'),
    S(t') => v
  
  // <one> [a, b, c, ...]
  T t, TF tf |- One(s) --> v
  where
    isATermList(t) == true,
    getAllSubterms[t]() => ts,
    makeList[tf](ts) => ats,
    T ats |- first(s) -first-> v,
    v => S(t')
  
  // <one> TNAME(t1, t2, t3, ...)
  T t, TF tf |- One(s) --> v
  where
    isATermAppl(t) == true,
    asATermAppl(t) => at,
    getConstructor[at]() => ac,
    getAllSubterms[at]() => ts,
    makeList[tf](ts) => ats,
    T ats |- first(s) -first-> S(ats'),
    isATermList(ats') == true,
    makeAppl[tf](ac, ts) => t',
    annotateTerm[tf](t', getAnnotations[t]()) => t'', // copy over annotations
    S(t'') => v
  
  One(s) --> F()
  where all-fail
  
  // empty candidate list
  T t |- first(s) -first-> v
  where
    isATermList(t) == true,
    asATermList(t) => lt,
    isEmpty[lt]() == true,
    F() => v
  
  // non-empty head success
  T t, TF tf |- first(s) -first-> v
  where
    isATermList(t) == true,
    asATermList(t) => lt,
    isEmpty[lt]() == false,
    head[lt]() => th,
    tail[lt]() => tl,
    T th |- s --> v1,
    v1 => S(th'),
    makeListCons[tf](th', tl) => t',
    S(t') => v
  
  // non-empty head success
  T t, TF tf |- first(s) -first-> v
  where
    isATermList(t) == true,
    asATermList(t) => lt,
    isEmpty[lt]() == false,
    head[lt]() => th,
    tail[lt]() => tl,
    T th |- s --> v1,
    v1 => F(),
    T tl |- first(s) -first-> S(tl'),
    isATermList(tl') == true,
    asATermList(tl') => tl'',
    makeListCons[tf](th, asATermList(tl')) => t',
    S(t') => v
  
  first(s) -first-> F()
  where all-fail

rules // term traversal: some

  // TODO <some> (t1, t2, ...)
  T t, TF tf |- Some(s) --> v
  where
    isATermTuple(t) == true,
    getAllSubterms[t]() => ts,
    makeList[tf](ts) => ats,
    T ats |- (oneOrMore(s), Bool false) -some-> (t', Bool f),
    f == true,
    S(t') => v
     
  
  // TODO <some> [t1, t2, ...]
  // TODO <some> TNAME(t1, t2, )

  Some(s) --> F()
  where all-fail

signature
  internal-sorts
    Somer
    
  internal-constructors
    oneOrMore : Strategy -> Somer

  arrows
    Somer -some-> TLIST

rules
  
  // case t == []: return untouched list
  T t, TF tf |- (oneOrMore(s), Bool f) -some-> (list, Bool false)
  where
    isATermList(t) == true,
    asATermList(t) => list,
    isEmpty[list]() == true
  
  // case t == [t1 | ts] and <not(s)> t1
  T t, TF tf |- (oneOrMore(s), Bool f) -some-> (list', Bool f'')
  where
    isATermList(t) == true,
    asATermList(t) => list,
    isEmpty[list]() == false,
    head[list]() => head,
    tail[list]() => tail,
    T head |- s --> vhead,
    vhead => F(),
    T tail |- (oneOrMore(s), Bool f) -some-> (tail', Bool f'),
    makeListCons[tf](head, tail') => list',
    booleanOr(f, f') => f''
  
  // case t == [t1 | t2] and <s> t1 
  T t, TF tf |- (oneOrMore(s), Bool f) -some-> (list', Bool true)
  where
    isATermList(t) == true,
    asATermList(t) => list,
    isEmpty[list]() == false,
    head[list]() => head,
    tail[list]() => tail,
    T head |- s --> vhead,
    vhead => S(head'),
    T tail |- (oneOrMore(s), Bool true) -some-> (tail', Bool f'),
    makeListCons[tf](head', tail') => list'
    

