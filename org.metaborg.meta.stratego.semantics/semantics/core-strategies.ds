module core-strategies
/*
 *
 * Specifications for:
 *   - id
 *   - fail
 *   - variable scoping
 *   - all
 *   - one
 *
*/
imports
  stratego-signatures
  aterm
  shared
  state
  
rules // identity and failure

  T t |- Id() --> S(t)
  
  Fail() --> F()

/*
rules // scope (one at a time)
  
  VEnv e |- Scope([], s) --> t'
  where
    VEnv e |- s --> t'

  VEnv e |- Scope([x | xs], s) --> v
  where
    VPush(e, x) -vinit-> e',
    VEnv e' |- Scope(xs, s) --> v
*/

rules // scope (all at once)

  VEnv e |- Scope(vs, s) --> v
  where
    VPushBatch(e, vs) -vinit-> e',
    VEnv e' |- s --> v

signature
  internal-sorts
    Mapper
    
  internal-constructors
    map : Strategy -> Mapper

  arrows
    Mapper -map-> Value
    
rules // term traversal: all

  // <all> 42
  T t |- All(_) --> S(t)
  where
    t : TINT

  // <all> "4.5"
  T t |- All(_) --> S(t)
  where
    t : TREAL
  
  // <all> "string"
  T t |- All(_) --> S(t)
  where
    t : TSTR
  
  // <all> (tup1, tup2, ...)
  T t, TF tf |- All(s) --> S(t'')
  where
    t : TTUP,
    getAllSubterms[t]() => ts,
    makeList[tf](ts) => ats, // FIXME: extremely inefficient
    T ats |- map(s) -map-> S(ats'),
    ats' : TLIST, 
    getAllSubterms[ats']() => ts',
    makeTuple[tf](ts') => t',
    annotateTerm[tf](t', getAnnotations[t]()) => t''

  // <all> [a, b, c, ...]
  T t, TF tf |- All(s) --> S(ats'')
  where
    t : TLIST,
    T t |- map(s) -map-> S(ats'),
    annotateTerm[tf](ats', getAnnotations[t]()) => ats''

  // <all> TNAME(t1, t2, ...)
  T t, TF tf |- All(s) --> S(t'')
  where
    t : TAPPL,
    getConstructor[t]() => ac,
    getAllSubterms[t]() => ts,
    makeList[tf](ts) => ats, // FIXME: extremely inefficient
    T ats |- map(s) -map-> S(ats'),
    ats' : TLIST,
    getAllSubterms[ats']() => ts', // FIXME: extremely inefficient
    makeAppl[tf](ac, ts') => t',
    annotateTerm[tf](t', getAnnotations[t]()) => t'' // copy over the old annotations

  All(_) --> F()
  where
    all-fail

  T t |- map(_) -map-> S(t)
  where
    t : TLIST,
    isEmpty[t]() == true
  
  T t, TF tf |- map(s) -map-> S(ts'')
  where
    t : TLIST,
    isEmpty[t]() == false,
    head[t]() => th,
    tail[t]() => ts,
    T th |- s --> S(th'),
    T ts |- map(s) -map-> S(ts'),
    ts' : TLIST,
    makeListCons[tf](th', ts') => ts''

  map(_) -map-> F()
  where
    all-fail

signature
  internal-sorts
    Firster
    
  internal-constructors
    first : Strategy -> Firster
  
  arrows
    Firster -first-> Value

rules // term traversal: one
  
  // <one> (tup1, tup2, ...)
  T t, TF tf |- One(s) --> S(t'')
  where
    t : TTUP,
    getAllSubterms[t]() => ts,
    makeList[tf](ts) => ats,
    T ats |- first(s) -first-> S(t'),
    annotateTerm[tf](t', getAnnotations[t]()) => t''
  
  // <one> [a, b, c, ...]
  T t, TF tf |- One(s) --> S(ats'')
  where
    t : TLIST,
    getAllSubterms[t]() => ts,
    makeList[tf](ts) => ats,
    T ats |- first(s) -first-> S(ats'),
    annotateTerm[tf](ats', getAnnotations[t]()) => ats''
  
  // <one> TNAME(t1, t2, t3, ...)
  T t, TF tf |- One(s) --> S(t'')
  where
    t : TAPPL,
    getConstructor[t]() => ac,
    getAllSubterms[t]() => ts,
    makeList[tf](ts) => ats,
    T ats |- first(s) -first-> S(ats'),
    ats' : TLIST,
    getAllSubterms[ats']() => ts',
    makeAppl[tf](ac, ts') => t',
    annotateTerm[tf](t', getAnnotations[t]()) => t'' // copy over annotations
  
  One(_) --> F()
  where all-fail
  
  // empty candidate list
  T t |- first(_) -first-> F()
  where
    t : TLIST,
    isEmpty[t]() == true
  
  // non-empty head success
  T t, TF tf |- first(s) -first-> S(t')
  where
    t : TLIST,
    isEmpty[t]() == false,
    head[t]() => th,
    tail[t]() => tl,
    T th |- s --> S(th'),
    makeListCons[tf](th', tl) => t'
  
  // non-empty head failure
  T t, TF tf |- first(s) -first-> S(t')
  where
    t : TLIST,
    isEmpty[t]() == false,
    head[t]() => th,
    tail[t]() => tl,
    T th |- s --> F(),
    T tl |- first(s) -first-> S(tl'),
    tl' : TLIST,
    makeListCons[tf](th, tl') => t'
  
  first(_) -first-> F()
  where all-fail

rules // term traversal: some

  // <some> (t1, t2, ...)
  T t, TF tf |- Some(s) --> S(t')
  where
    t : TTUP,
    getAllSubterms[t]() => ts,
    makeList[tf](ts) => ats,
    T ats |- (oneOrMore(s), Bool false) -some-> (ats', Bool true),
    getAllSubterms[ats']() => ts',
    makeTuple[tf](ts') => t',
    annotateTerm[tf](t', getAnnotations[t]()) => _
  
  // <some> [t1, t2, ...]
  T t, TF tf |- Some(s) --> S(ats')
  where
    t : TLIST,
    getAllSubterms[t]() => ts,
    makeList[tf](ts) => ats,
    T ats |- (oneOrMore(s), Bool false) -some-> (ats', Bool true),
    annotateTerm[tf](ats', getAnnotations[t]()) => _

  // <some> TNAME(t1, t2, )
  T t, TF tf |- Some(s) --> S(t'')
  where
    t : TAPPL,
    getConstructor[t]() => ac,
    getAllSubterms[t]() => ts,
    makeList[tf](ts) => ats,
    T ats |- (oneOrMore(s), Bool false) -some-> (ats', Bool true),
    getAllSubterms[ats']() => ts',
    makeAppl[tf](ac, ts') => t',
    annotateTerm[tf](t', getAnnotations[t]()) => t'' // copy over annotations

  Some(_) --> F()
  where all-fail

signature
  internal-sorts
    Somer
    
  internal-constructors
    oneOrMore : Strategy -> Somer

  arrows
    Somer -some-> TLIST

rules
  
  // case t == []: return untouched list
  T t |- (oneOrMore(_), Bool _) -some-> (t, Bool false)
  where
    t : TLIST,
    isEmpty[t]() == true
  
  // case t == [t1 | ts] and <not(s)> t1
  T t, TF tf |- (oneOrMore(s), Bool f) -some-> (list', Bool boolOr(f, f'))
  where
    t : TLIST,
    isEmpty[t]() == false,
    head[t]() => head,
    tail[t]() => tail,
    T head |- s --> F(),
    T tail |- (oneOrMore(s), Bool f) -some-> (tail', Bool f'),
    makeListCons[tf](head, tail') => list'
  
  // case t == [t1 | t2] and <s> t1 
  T t, TF tf |- (oneOrMore(s), Bool _) -some-> (list', Bool true)
  where
    t : TLIST,
    isEmpty[t]() == false,
    head[t]() => head,
    tail[t]() => tail,
    T head |- s --> S(head'),
    T tail |- (oneOrMore(s), Bool true) -some-> (tail', Bool _),
    makeListCons[tf](head', tail') => list'
    
