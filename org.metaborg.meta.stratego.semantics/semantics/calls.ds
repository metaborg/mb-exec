module calls

imports
  stratego-signatures
  shared
  build
  aterm
  state
  tracing
  
rules // calls

  VEnv e, SEnv d |- CallT(SVar(sname), ass, ats) --> v
  where
    SLookup(d, sname) -slook-> SLookupResult(e', thunk),
    thunk => Thunk(sname'', fss, fts, s, e_def, d_def),
    VEnv e |- bl(ats) -blds-> BSS(ats'), // build term arguments     
    VEnv e_def |- bindtvars(fts, ats') -bindtvars-> e_call, // bind term arguments
    VEnv e, SEnv d |- bindsvars(fss, ass, d_def) -bindsvars-> d_call, // bind strategy arguments
    VEnv e_call, SEnv d_call |- tracing(sname, s) --> v // do the call while tracing
      
  VEnv e, SEnv d |- CallT(dc1, dc2, dc3) --> F()
  where
    all-fail

signature
  internal-sorts
    Binder
    
  internal-constructors
    bindtvars: List(String) * List(T) -> Binder
    
  arrows
    Binder -bindtvars-> VEnv
    
rules

  VEnv e |- bindtvars([], []) -bindtvars-> e
  
  VEnv e |- bindtvars([x | xxs], [t | txs]) -bindtvars-> e''
  where
    VPushUpdate(e, x, S(t)) -vinit-> e',
    VEnv e' |- bindtvars(xxs, txs) -bindtvars-> e''

signature
  internal-constructors
    bindsvars: List(String) * List(Strategy) * SEnv -> Binder
    
  arrows
    Binder -bindsvars-> SEnv

  native-operators
    createAnonymousName : String -> String

rules
  /*
    Bind formal strategy parameters to actual strategies.
    
    We extend the Strategy definition environment at the definition of the callee whose formal parameters need to be bound.
    We basically copy into the definition environment mappings from the call-site environmetn.
  */

  VEnv e, SEnv d |- bindsvars([], [], d_into) -bindsvars-> d_into
 
  // 1. CallT without arguments
  VEnv e, SEnv d |- bindsvars([x | xs], [s | ss], d_into) -bindsvars-> d_into''
  where
    s => CallT(SVar(tgt), [], []),
    SLookup(d, tgt) -slook-> SLookupResult(d', Thunk(tgt'', fss, fts, sactual, e_tgt, d_tgt)),
    SPush(d_into, x, Thunk(x, fss, fts, sactual, e_tgt, d_tgt)) -salloc-> d_into',
    VEnv e, SEnv d |- bindsvars(xs, ss, d_into') -bindsvars-> d_into''

  
  // 2. CallT with arguments
  VEnv e, SEnv d |- bindsvars([x | xs], [s | ss], d_into) -bindsvars-> d_into''
  where
    s => CallT(SVar(tgt), ass, ats),
    boolAnd(isEmpty(ass), isEmpty(ats)) == false,
    SLookup(d, tgt) -slook-> SLookupResult(d', Thunk(tgt'', fss, fts, sactual, e_tgt, d_tgt)),
    VEnv e, SEnv d |- bl(ats) -blds-> BSS(ats'),
    VEnv e_tgt |- bindtvars(fts, ats') -bindtvars-> e_tgt',
    VEnv e, SEnv d |- bindsvars(fss, ass, d_tgt) -bindsvars-> d_tgt',
    SPush(d_into, x, Thunk(x, [], [], sactual, e_tgt', d_tgt')) -salloc-> d_into',
    VEnv e, SEnv d |- bindsvars(xs, ss, d_into') -bindsvars-> d_into''

  // 3. A strategy literal body (not a call)
  VEnv e, SEnv d |- bindsvars([x | xs], [s | ss], d_into) -bindsvars-> d_into''
  where
    s =!=> CallT(SVar(_), _, _),
    SPush(d_into, x, Thunk(x, [], [], s, e, d)) -salloc-> d_into',
    VEnv e, SEnv d |- bindsvars(xs, ss, d_into') -bindsvars-> d_into''
  
signature

  native-constructors
    primCall : String * List(Thunk) * List(T) -> Strategy

rules // primitives

  IC ic, VEnv e, SEnv d |- PrimT(sname, ass, ats) --> v
  where
    VEnv e |- bl(ats) -blds-> BSS(ats'),
    mkThunks(ass) -thunks-> thunks,
    primCall(sname, thunks, ats') --> v
    
  T t, IC ic |- PrimT(name, ass, ats) --> F()
  where
    all-fail

signature
  internal-sorts
    Thunker

  internal-constructors
    mkThunk  : Strategy -> Thunker
    mkThunks : List(Strategy) -> Thunker

  arrows
    Thunker -thunks-> List(Thunk)
    Thunker -thunk-> Thunk

rules

  mkThunks([]) -thunks-> []
  
  mkThunks([as | ass]) -thunks-> [as' | ass']
  where
    mkThunk(as) -thunk-> as',
    mkThunks(ass) -thunks-> ass'

  VEnv e, SEnv d |- mkThunk(s) -thunk-> thunk
  where
    s => CallT(SVar(tgt), ass, ats),
    SLookup(d, tgt) -slook-> SLookupResult(d', thunk),
    thunk => Thunk(tgt', fss, fts, sactual, e_tgt, d_tgt)
  
  VEnv e, SEnv d |- mkThunk(s) -thunk-> Thunk(x, [], [], s, e, d)
  where
    s =!=> CallT(_, _, _),
    createAnonymousName("lifted") => x

rules // dynamic call
  
  CallDynamic(target, ass, ats) --> v
  where
    Build(target) --> S(sname_aterm),
    sname_aterm : TSTR,
    stringValue[sname_aterm]() => sname,
    CallT(SVar(sname), ass, ats) --> v
