module calls

imports
  stratego-signatures
  shared
  build
  aterm
  state
  tracing
  
rules // calls

  VEnv e, SEnv d |- CallT(SVar(sname), ass, ats) --> v
  where
    SEnv d |- SLookup(sname) -slook-> Thunk(_, fss, fts, s, e_def, d_def),
    VEnv e |- bl(ats) -blds-> BSS(ats'), // build term arguments     
    VEnv e_def |- bindtvars(fts, ats') -bindtvars-> e_call, // bind term arguments
    VEnv e, SEnv d |- bindsvars(fss, ass, d_def) -bindsvars-> d_call, // bind strategy arguments
    VEnv e_call, SEnv d_call |- tracing(sname, s) --> v // do the call while tracing
      
  CallT(_, _, _) --> F()
  where
    all-fail

signature
  internal-sorts
    Binder
    
  internal-constructors
    bindtvars: List(String) * List(T) -> Binder
    
  arrows
    Binder -bindtvars-> VEnv
    
rules

  VEnv e |- bindtvars([], []) -bindtvars-> e
  
  VEnv e |- bindtvars([x | xxs], [t | txs]) -bindtvars-> e''
  where
    (VPushUpdate(x, S(t)), VEnv e) -vinit-> (_, VEnv e'),
    VEnv e' |- bindtvars(xxs, txs) -bindtvars-> e''

signature
  internal-constructors
    bindsvars: List(String) * List(Strategy) * SEnv -> Binder
  
  native-operators
    isEmptyStrategies: List(Strategy) -> Bool

  arrows
    Binder -bindsvars-> SEnv

  native-operators
    createAnonymousName : String -> String

rules
  /*
    Bind formal strategy parameters to actual strategies.
    
    We extend the Strategy definition environment at the definition of the callee whose formal parameters need to be bound.
    We basically copy into the definition environment mappings from the call-site environmetn.
  */

  bindsvars([], [], d_into) -bindsvars-> d_into
 
  // 1. CallT without arguments
  VEnv e, SEnv d |- bindsvars([x | xs], [CallT(SVar(tgt), ass, ats) | ss], d_into) -bindsvars-> d_into''
  where
    boolAnd(isEmptyStrategies(ass), isEmpty(ats)) == true,
    SEnv d |- SLookup(tgt) -slook-> Thunk(_, fss, fts, sactual, e_tgt, d_tgt),
    (SPush(x, Thunk(x, fss, fts, sactual, e_tgt, d_tgt)), SEnv d_into) -salloc-> (_, SEnv d_into'),
    VEnv e, SEnv d |- bindsvars(xs, ss, d_into') -bindsvars-> d_into''
  
  // 2. CallT with arguments
  VEnv e, SEnv d |- bindsvars([x | xs], [CallT(SVar(tgt), ass, ats) | ss], d_into) -bindsvars-> d_into''
  where
    boolAnd(isEmptyStrategies(ass), isEmpty(ats)) == false,
    SEnv d |- SLookup(tgt) -slook-> Thunk(_, fss, fts, sactual, e_tgt, d_tgt),
    VEnv e, SEnv d |- bl(ats) -blds-> BSS(ats'),
    VEnv e_tgt |- bindtvars(fts, ats') -bindtvars-> e_tgt',
    VEnv e, SEnv d |- bindsvars(fss, ass, d_tgt) -bindsvars-> d_tgt',
    (SPush(x, Thunk(x, [], [], sactual, e_tgt', d_tgt')), SEnv d_into) -salloc-> (_, SEnv d_into'),
    VEnv e, SEnv d |- bindsvars(xs, ss, d_into') -bindsvars-> d_into''

  // 3. A strategy literal body (not a call)
  VEnv e, SEnv d |- bindsvars([x | xs], [s | ss], d_into) -bindsvars-> d_into''
  where
    s =!=> CallT(SVar(_), _, _),
    (SPush(x, Thunk(x, [], [], s, e, d)), SEnv d_into) -salloc-> (U(), SEnv d_into'),
    VEnv e, SEnv d |- bindsvars(xs, ss, d_into') -bindsvars-> d_into''
    
signature

  native-constructors
    primCall : String * List(Thunk) * List(T) -> Strategy

rules // primitives

  VEnv e |- PrimT(sname, ass, ats) --> v
  where
    VEnv e |- bl(ats) -blds-> BSS(ats'),
    mkThunks(ass) -thunks-> thunks,
    primCall(sname, thunks, ats') --> v

  PrimT(_, _, _) --> F()
  where
    all-fail

signature
  internal-sorts
    Thunker

  internal-constructors
    mkThunk  : Strategy -> Thunker
    mkThunks : List(Strategy) -> Thunker

  arrows
    Thunker -thunks-> List(Thunk)
    Thunker -thunk-> Thunk

rules

  mkThunks([]) -thunks-> []
  
  mkThunks([as | ass]) -thunks-> [as' | ass']
  where
    mkThunk(as) -thunk-> as',
    mkThunks(ass) -thunks-> ass'

  SEnv d |- mkThunk(CallT(SVar(tgt), _, _)) -thunk-> thunk
  where
    SEnv d |- SLookup(tgt) -slook-> thunk
  
  VEnv e, SEnv d |- mkThunk(s) -thunk-> Thunk(x, [], [], s, e, d)
  where
    s =!=> CallT(_, _, _),
    createAnonymousName("lifted") => x

rules // dynamic call
  
  CallDynamic(target, ass, ats) --> v
  where
    Build(target) --> S(sname_aterm),
    sname_aterm : TSTR,
    stringValue[sname_aterm]() => sname,
    CallT(SVar(sname), ass, ats) --> v
