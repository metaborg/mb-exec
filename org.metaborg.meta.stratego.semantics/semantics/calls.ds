module calls

imports
  semantics/stratego-signatures
  semantics/shared
  semantics/build
  semantics/aterm
  semantics/state
  semantics/tracing
  
rules // calls

  venv, senv |- CallT(SVar(sname), ass, ats) --> v
  where
    senv |- SLookup(sname) -slook-> Thunk(_, fss, fts, s, venv_def, senv_def);
    venv |- bl(ats) -blds-> BSS(ats'); // build term arguments    
    bindtvars(fts, ats') :: venv_def -bindtvars-> _ :: venv_call; // bind term arguments
    venv, senv |- bindsvars(fss, ass, senv_def) -bindsvars-> senv_call; // bind strategy arguments
    venv_call, senv_call |- tracing(sname, s) --> v. // do the call while tracing
      
  CallT(_, _, _) --> F()
  where
    all-fail.

signature
  sorts
    Binder
    
  constructors
    bindtvars: List(String) * List(T) -> Binder
    
  arrows
    Binder -bindtvars-> Unit
    
rules

  bindtvars([], []) -bindtvars-> U().
  
  bindtvars([x | xxs], [t | txs]) -bindtvars-> U()
  where
    VPushUpdate(x, S(t)) -vinit-> _;
    bindtvars(xxs, txs) -bindtvars-> _.

signature
  constructors
    bindsvars: List(String) * List(Strategy) * Map<String, SBox> -> Binder
  
  native operators
    isEmptyStrategies: List(Strategy) -> Bool

  arrows
    Binder -bindsvars-> Map<String, SBox>

  native operators
    createAnonymousName : String -> String

rules
  /*
    Bind formal strategy parameters to actual strategies.
    
    We extend the Strategy definition environment at the definition of the callee whose formal parameters need to be bound.
    We basically copy into the definition environment mappings from the call-site environmetn.
  */

  bindsvars([], [], d_into) -bindsvars-> d_into.
 
  // 1. CallT without arguments
  senv |- bindsvars([x | xs], [CallT(SVar(tgt), ass, ats) | ss], senv_in) -bindsvars-> senv_in''
  where
    boolAnd(isEmptyStrategies(ass), isEmpty(ats)) == true;
    senv |- SLookup(tgt) -slook-> Thunk(_, fss, fts, sactual, e_tgt, d_tgt);
    SPush(x, Thunk(x, fss, fts, sactual, e_tgt, d_tgt)) :: senv_in -salloc-> _ :: senv_in';
    senv |- bindsvars(xs, ss, senv_in') -bindsvars-> senv_in''.
  
  // 2. CallT with arguments
  venv, senv |- bindsvars([x | xs], [CallT(SVar(tgt), ass, ats) | ss], senv_into) -bindsvars-> d_into''
  where
    boolAnd(isEmptyStrategies(ass), isEmpty(ats)) == false;
    senv |- SLookup(tgt) -slook-> Thunk(_, fss, fts, sactual, venv_tgt, senv_tgt);
    venv, senv |- bl(ats) -blds-> BSS(ats');
    bindtvars(fts, ats') :: venv_tgt -bindtvars-> _ :: venv_tgt';
    venv, senv |- bindsvars(fss, ass, senv_tgt) -bindsvars-> senv_tgt';
    SPush(x, Thunk(x, [], [], sactual, venv_tgt', senv_tgt')) :: senv_into -salloc-> _ :: senv_into';
    venv, senv |- bindsvars(xs, ss, senv_into') -bindsvars-> d_into''.

  // 3. A strategy literal body (not a call)
  venv, senv |- bindsvars([x | xs], [s | ss], senv_into) -bindsvars-> senv_into''
  where
    s =!=> CallT(SVar(_), _, _);
    SPush(x, Thunk(x, [], [], s, venv, senv)) :: senv_into -salloc-> U() :: senv_into';
    venv, senv |- bindsvars(xs, ss, senv_into') -bindsvars-> senv_into''.
    
signature

  native constructors
    primCall : String * List(Thunk) * List(T) -> Strategy

rules // primitives

  venv |- PrimT(sname, ass, ats) --> v
  where
    venv |- bl(ats) -blds-> BSS(ats');
    mkThunks(ass) -thunks-> thunks;
    primCall(sname, thunks, ats') --> v.

  PrimT(_, _, _) --> F()
  where
    all-fail.

signature
  sorts
    Thunker

  constructors
    mkThunk  : Strategy -> Thunker
    mkThunks : List(Strategy) -> Thunker

  arrows
    Thunker -thunks-> List(Thunk)
    Thunker -thunk-> Thunk

rules

  mkThunks([]) -thunks-> [] : List(Thunk).
  
  mkThunks([as | ass]) -thunks-> [as' | ass']
  where
    mkThunk(as) -thunk-> as';
    mkThunks(ass) -thunks-> ass'.

  senv |- mkThunk(CallT(SVar(tgt), _, _)) -thunk-> thunk
  where
    senv |- SLookup(tgt) -slook-> thunk.
  
  venv, senv |- mkThunk(s) -thunk-> Thunk(x, [], [], s, venv, senv)
  where
    s =!=> CallT(_, _, _);
    createAnonymousName("lifted") => x.

rules // dynamic call
  
  CallDynamic(target, ass, ats) --> v
  where
    Build(target) --> S(sname_aterm);
    sname_aterm <: TSTR;
    stringValue[sname_aterm]() => sname;
    CallT(SVar(sname), ass, ats) --> v.
