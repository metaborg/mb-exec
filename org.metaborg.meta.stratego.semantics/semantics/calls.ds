module calls

imports
  base
  stratego-signatures
  shared
  build
  definitions
  aterm
  state
  
rules // calls


  Int e, D defs |- CallT(SVar(sname), ass, ats) --> v
  where
    defs[sname] => Thunk(sname', fss, fts, s, e_def),
    Int e |- bl(ats) -blds-> BSS(ats'), // build term arguments
    Int e_def |- bindtvars(fts, ats') -bindtvars-> e_call, // bind term arguments
    Int e, D defs |- bindsvars(fss, ass) -bindsvars-> new_defs, // bind svars
    Int e_call, D {new_defs, defs} |- s --> v
    
  Int e, D defs |- CallT(dc1, dc2, dc3) --> F()
  where
    all-fail

signature
  internal-sorts
    Binder
    
  internal-constructors
    bindtvars: List(String) * List(T) -> Binder
    
  arrows
    Binder -bindtvars-> Int
    
rules

  Int e |- bindtvars([], []) -bindtvars-> e
  
  Int e |- bindtvars([x | xxs], [t | txs]) -bindtvars-> e''
  where
    PushUpdate(e, x, S(t)) -init-> e',
    Int e' |- bindtvars(xxs, txs) -bindtvars-> e''

signature
  internal-constructors
    bindsvars: List(String) * List(Strategy) -> Binder
    bindsvar: String * Strategy -> Binder
    
  arrows
    Binder -bindsvars-> D

  native-operators
    createAnonymousName : String -> String

rules

  Int e, D sdefs |- bindsvars([], []) -bindsvars-> sdefs

  // 1. CallT without arguments
  Int e, D sdefs |- bindsvars([x | xs], [s | ss]) -bindsvars-> { x |--> Thunk(name, fss, fts, sactual, defEnv), binds }
  where
    s => CallT(SVar(name), ass, ats),
    ass => [],
    ats => [],
    sdefs[name] => thunk,
    thunk => Thunk(name', fss, fts, sactual, defEnv),
    bindsvars(xs, ss) -bindsvars-> binds
    
  // 2. CallT with arguments
  Int e, D sdefs |- bindsvars([x | xs], [s | ss]) -bindsvars-> { { x |--> Thunk(annonx, [], [], s, e), binds' }, binds'' }
  where
    s => CallT(SVar(name), ass, ats),
    ass => [ass1 | ass2],
    createAnonymousName(x) => annonx,
    Int e, D sdefs |- bindsvar(x, s) -bindsvars-> binds',
    Int e, D sdefs |- bindsvars(xs, ss) -bindsvars-> binds''
  
  Int e, D sdefs |- bindsvars([x | xs], [s | ss]) -bindsvars-> { { x |--> Thunk(annonx, [], [], s, e), binds' }, binds'' }
  where
    s => CallT(SVar(name), ass, ats),
    ats => [ats1 | ats2],
    createAnonymousName(x) => annonx,
    Int e, D sdefs |- bindsvar(x, s) -bindsvars-> binds',
    Int e, D sdefs |- bindsvars(xs, ss) -bindsvars-> binds''
  
  // helper for binding a fully applied svar
  Int e, D sdefs |- bindsvar(x, s) -bindsvars-> { x |--> Thunk(name, [], [], sactual, e_call), new_defs }
  where
    s => CallT(SVar(name), ass, ats),
    sdefs[name] => Thunk(name', fss, fts, sactual, e_def),
    Int e |- bl(ats) -blds-> BSS(ats'), // build term arguments
    Int e_def |- bindtvars(fts, ats') -bindtvars-> e_call, // bind term arguments
    Int e, D sdefs |- bindsvars(fss, ass) -bindsvars-> new_defs // bind svars
    
  // 3. not a CallT
  Int e, D sdefs |- bindsvars([x | xs], [s | ss]) -bindsvars-> { x |--> Thunk(annonx, [], [], s, e), binds }
  where
    s =!=> CallT(SVar(name), ass, ats),
    createAnonymousName(x) => annonx,
    bindsvars(xs, ss) -bindsvars-> binds
  
signature

  native-datatypes
	  "ds.manual.interpreter.AutoInterpInteropContext" as IC {
	    
	  }

  native-operators
    primCall : IC * String * List(Strategy) * List(T) * T -> Value

rules // primitives

  T t, IC ic |- PrimT(name, ass, ats) --> v
  where
    bl(ats) -blds-> BSS(ats_aterms),
    primCall(ic, name, ass, ats_aterms, t) => v // implement in Java
  
  T t, IC ic |- PrimT(name, ass, ats) --> F()
  where
    all-fail

rules // dynamic call
  
  CallDynamic(target, ass, ats) --> v
  where
    Build(target) --> S(sname_aterm),
    isATermString(sname_aterm) == true,
    asATermString(sname_aterm) => sname_aterm_str,
    stringValue[sname_aterm_str]() => sname,
    CallT(SVar(sname), ass, ats) --> v
