module calls

imports
  base
  stratego-signatures
  shared
  build
  aterm
  state
  
rules // calls

  VEnv e, SEnv d |- CallT(SVar(sname), ass, ats) --> v
  where
    SLookup(d, sname) -slook-> SLookupResult(d_at_loc, SBind(sname', thunk, d_next_loc)),
    thunk => Thunk(sname'', fss, fts, s, e_def, d_def),
    VEnv e |- bl(ats) -blds-> BSS(ats'), // build term arguments     
    VEnv e_def |- bindtvars(fts, ats') -bindtvars-> e_call, // bind term arguments
    VEnv e, SEnv d |- bindsvars(fss, ass, d_def) -bindsvars-> d_call, // bind strategy arguments
    VEnv e_call, SEnv d_call |- s --> v // do the call
      
  VEnv e, SEnv d |- CallT(dc1, dc2, dc3) --> F()
  where
    all-fail

signature
  internal-sorts
    Binder
    
  internal-constructors
    bindtvars: List(String) * List(T) -> Binder
    
  arrows
    Binder -bindtvars-> VEnv
    
rules

  VEnv e |- bindtvars([], []) -bindtvars-> e
  
  VEnv e |- bindtvars([x | xxs], [t | txs]) -bindtvars-> e''
  where
    VPushUpdate(e, x, S(t)) -vinit-> e',
    VEnv e' |- bindtvars(xxs, txs) -bindtvars-> e''

signature
  internal-constructors
    bindsvars: List(String) * List(Strategy) * SEnv -> Binder
    
  arrows
    Binder -bindsvars-> SEnv

  native-operators
    createAnonymousName : String -> String

rules
  /*
    Bind formal strategy parameters to actual strategies.
    
    We extend the Strategy definition environment at the definition of the callee whose formal parameters need to be bound.
    We basically copy into the definition environment mappings from the call-site environmetn.
  */


  VEnv e, SEnv d |- bindsvars([], [], d_into) -bindsvars-> d_into
 
  // 1. CallT without arguments
  VEnv e, SEnv d |- bindsvars([x | xs], [s | ss], d_into) -bindsvars-> d_into''
  where
    s => CallT(SVar(tgt), ass, ats),
    isEmpty(ass) => empty_ass,
    isEmpty(ats) => empty_ats,
    booleanAnd(empty_ass, empty_ats) == true,
    SLookup(d, tgt) -slook-> SLookupResult(d_at_loc, SBind(tgt', Thunk(tgt'', fss, fts, sactual, e_tgt, d_tgt), d_next_loc)),
    SPush(d_into, x, Thunk(x, fss, fts, sactual, e_tgt, d_tgt)) -salloc-> d_into',
    VEnv e, SEnv d |- bindsvars(xs, ss, d_into') -bindsvars-> d_into''

  
  // 2. CallT with arguments
  VEnv e, SEnv d |- bindsvars([x | xs], [s | ss], d_into) -bindsvars-> d_into'' // { x |--> Thunk(x, [], [], s, e_tgt', d_tgt'), d_callee' }
  where
    s => CallT(SVar(tgt), ass, ats),
    isEmpty(ass) => empty_ass,
    isEmpty(ats) => empty_ats,
    booleanAnd(empty_ass, empty_ats) == false,
    SLookup(d, tgt) -slook-> SLookupResult(d_at_loc, SBind(tgt', Thunk(tgt'', fss, fts, sactual, e_tgt, d_tgt), d_next_loc)),
    VEnv e, SEnv d |- bl(ats) -blds-> BSS(ats'),
    VEnv e_tgt |- bindtvars(fts, ats') -bindtvars-> e_tgt',
    VEnv e, SEnv d |- bindsvars(fss, ass, d_tgt) -bindsvars-> d_tgt',
    SPush(d_into, x, Thunk(x, [], [], sactual, e_tgt', d_tgt')) -salloc-> d_into',
    VEnv e, SEnv d |- bindsvars(xs, ss, d_into') -bindsvars-> d_into''

  // 3. A strategy literal body (not a call)
  VEnv e, SEnv d |- bindsvars([x | xs], [s | ss], d_into) -bindsvars-> d_into''
  where
    s =!=> CallT(SVar(tgt), ass, ats),
    SPush(d, x, Thunk(x, [], [], s, e, d)) -salloc-> d_into',
    VEnv e, SEnv d |- bindsvars(xs, ss, d_into') -bindsvars-> d_into''
  
signature

  native-datatypes
	  "ds.manual.interpreter.AutoInterpInteropContext" as IC {
	    
	  }

  native-operators
    primCall : IC * String * List(Strategy) * List(T) * T -> Value

rules // primitives

  T t, IC ic |- PrimT(name, ass, ats) --> v
  where
    bl(ats) -blds-> BSS(ats_aterms),
    primCall(ic, name, ass, ats_aterms, t) => v // implement in Java
  
  T t, IC ic |- PrimT(name, ass, ats) --> F()
  where
    all-fail

rules // dynamic call
  
  CallDynamic(target, ass, ats) --> v
  where
    Build(target) --> S(sname_aterm),
    isATermString(sname_aterm) == true,
    asATermString(sname_aterm) => sname_aterm_str,
    stringValue[sname_aterm_str]() => sname,
    CallT(SVar(sname), ass, ats) --> v
