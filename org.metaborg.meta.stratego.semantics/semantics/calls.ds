module calls

imports
  base
  stratego-signatures
  shared
  build
  definitions
  aterm
  state
  
// rules // calls
// 
//   Env e, D d |- CallT(SVar(sname), ass, ats) --> v
//   where
//     Env e, D d |-  SLookup(sname) -slook-> Thunk(sname', fss, fts, s, e_def, d_def),  
//     Env e |- bl(ats) -blds-> BSS(ats'), // build term arguments
//     Env e_def |- bindtvars(fts, ats') -bindtvars-> e_call, // bind term arguments in definition environment
//     Env e, D d |- bindsvars(fss, ass, d_def) -bindsvars-> d_call, // bind strategy arguments in the definition environment closing over the call site environment if necessary
//     Env e_call, D d_call |- s --> v // apply the body in the e_call and d_call environments
//       
//   Env e, D defs |- CallT(dc1, dc2, dc3) --> F()
//   where
//     all-fail
// 
// signature
//   internal-sorts
//     Binder
//     
//   internal-constructors
//     bindtvars: List(String) * List(T) -> Binder
//     
//   arrows
//     Binder -bindtvars-> Env
//     
// rules
// 
//   Env e |- bindtvars([], []) -bindtvars-> e
//   
//   Env e |- bindtvars([x | xxs], [t | txs]) -bindtvars-> e''
//   where
//     PushUpdate(e, x, S(t)) -init-> e',
//     Env e' |- bindtvars(xxs, txs) -bindtvars-> e''
// 
// signature
//   internal-constructors
//     bindsvars: List(String) * List(Strategy) * D -> Binder
//     
//     /*
//       bindsvar(formal parameter name, actual parameter strategy, Strategy definitions environment at the definition of the callee)
//     */
//     bindsvar: String * Strategy * D -> Binder
//     
//   arrows
//     Binder -bindsvars-> D
// 
//   native-operators
//     createAnonymousName : String -> String
// 
// rules
//   /*
//     Bind formal strategy parameters to actual strategies.
//     
//     We extend the Strategy definition environment at the definition of the callee whose formal parameters need to be bound.
//     We basically copy into the definition environment mappings from the call-site environmetn.
//   */
// 
// 
//   Env e, D d |- bindsvars([], [], d_def) -bindsvars-> d_def
//  
//   // 1. CallT without arguments
//   Env e, D d |- bindsvars([x | xs], [s | ss], d_callee) -bindsvars-> { x |--> Thunk(x, fss, fts, sactual, e_tgt, d_tgt), d_callee' }
//   where
//     s => CallT(SVar(tgt), ass, ats),
//     isEmpty(ass) => empty_ass,
//     isEmpty(ats) => empty_ats,
//     booleanAnd(empty_ass, empty_ats) == true,
//     Env e, D d |- SLookup(tgt) -slook-> Thunk(tgt', fss, fts, sactual, e_tgt, d_tgt),
//     Env e, D d |- bindsvars(xs, ss, d_callee) -bindsvars-> d_callee'
//   
//   // 2. CallT with arguments
//   Env e, D d |- bindsvars([x | xs], [s | ss], d_callee) -bindsvars-> { x |--> Thunk(x, [], [], s, e_tgt', d_tgt'), d_callee' }
//   where
//     s => CallT(SVar(tgt), ass, ats),
//     isEmpty(ass) => empty_ass,
//     isEmpty(ats) => empty_ats,
//     booleanAnd(empty_ass, empty_ats) == false,
//     Env e, D d |- SLookup(tgt) -slook-> Thunk(tgt', fss, fts, sactual, e_tgt, d_tgt),
//     Env e |- bl(ats) -blds-> BSS(ats'),
//     Env e_tgt |- bindtvars(fts, ats') -bindtvars-> e_tgt',
//     Env e, D d |- bindsvars(fss, ass, d_tgt) -bindsvars-> d_tgt',
//     Env e, D d |- bindsvars(xs, ss, d_callee) -bindsvars-> d_callee'
//   
//   // 3. A strategy literal body (not a call)
//   Env e, D d |- bindsvars([x | xs], [s | ss], d_callee) -bindsvars-> { x |--> Thunk(annonx, [], [], s, e, d), d_callee' }
//   where
//     s =!=> CallT(SVar(tgt), ass, ats),
//     createAnonymousName(x) => annonx,
//     Env e, D d |- bindsvars(xs, ss, d_callee) -bindsvars-> d_callee'
  
signature

  native-datatypes
	  "ds.manual.interpreter.AutoInterpInteropContext" as IC {
	    
	  }

  native-operators
    primCall : IC * String * List(Strategy) * List(T) * T -> Value

rules // primitives

  T t, IC ic |- PrimT(name, ass, ats) --> v
  where
    bl(ats) -blds-> BSS(ats_aterms),
    primCall(ic, name, ass, ats_aterms, t) => v // implement in Java
  
  T t, IC ic |- PrimT(name, ass, ats) --> F()
  where
    all-fail

rules // dynamic call
  
  CallDynamic(target, ass, ats) --> v
  where
    Build(target) --> S(sname_aterm),
    isATermString(sname_aterm) == true,
    asATermString(sname_aterm) => sname_aterm_str,
    stringValue[sname_aterm_str]() => sname,
    CallT(SVar(sname), ass, ats) --> v
