module state

imports
  shared
  stratego-signatures
  
/* === Rules for the Variables === */
signature

  semantic-components
    VEnv  -> Map<String, VBox>

  native-datatypes
    "ds.manual.interpreter.VState" as VHeap {
      lookup : VEnv * String -> Value
      alloc  : VEnv * String -> VEnv
      allocs : VEnv * List(String) -> VEnv
      update : VEnv * String * Value -> VEnv
      allocupdate : VEnv * String * Value -> VEnv
    }
    
    "ds.manual.interpreter.VBox" as VBox { }

  internal-sorts
    VLookupResult
  
  internal-constructors
    VLookupResult : VEnv * Value -> VLookupResult

  internal-sorts
    VHeapOp

  internal-constructors
    VLookup : String -> VHeapOp
    VUpdate : VEnv * String * Value -> VHeapOp
    VPush : VEnv * String -> VHeapOp
    VPushBatch : VEnv * List(String) -> VHeapOp
    VPushUpdate : VEnv * String * Value -> VHeapOp

  arrows
    VHeapOp -vlook-> Value
    VHeapOp -vupdate-> VEnv 
    VHeapOp -vinit-> VEnv
    
rules 
  
  VEnv venv, VHeap s |- VLookup(x) -vlook-> v
  where
    lookup[s](venv, x) => v
  
  (VUpdate(venv, x, v), VHeap s) -vupdate-> (venv, VHeap s)
  where
    update[s](venv, x, v) => _

  (VPush(venv, x), VHeap s) -vinit-> (venv', VHeap s)
  where
    alloc[s](venv, x) => venv'
  
  (VPushBatch(venv, xs), VHeap s) -vinit-> (venv', VHeap s)
  where
    allocs[s](venv, xs) => venv'
  
  (VPushUpdate(venv, x, v), VHeap s) -vinit-> (venv', VHeap s)
  where
    allocupdate[s](venv, x, v) => venv'

/* === Rules for the Strategies === */

signature
  semantic-components
    SEnv  -> Map<String, SBox>

  native-datatypes
    "ds.manual.interpreter.SState" as SHeap {
      lookup : SEnv * String -> Thunk
      alloc  : SEnv * String -> SEnv
      softalloc: SEnv * String -> SEnv
      allocupdate : SEnv * String * Thunk -> SEnv
      update : SEnv * String * Thunk -> SEnv
    }
    
    "ds.manual.interpreter.SBox" as SBox { }

  internal-sorts
    SLookupResult

  internal-constructors
    SLookupResult : SEnv * Thunk -> SLookupResult

  internal-sorts
    Thunk
  
  internal-constructors
    Thunk  : String * List(String) * List(String) * Strategy * VEnv * SEnv -> Thunk

  internal-sorts
    SHeapOp
  
  internal-constructors
    SAlloc: String -> SHeapOp
    SSoftAlloc: String -> SHeapOp
    SParAlloc : List(String) -> SHeapOp
    SUpdate : String * Thunk -> SHeapOp
    SPush: String * Thunk -> SHeapOp
    SLookup: String -> SHeapOp
    
  arrows
    SHeapOp -salloc-> Unit
  
    SHeapOp -slook-> Thunk
rules

  // Lookup a thunk by name at the starting SHeap address
  SHeap s, SEnv senv |- SLookup(name) -slook-> thunk
  where
    lookup[s](senv, name) => thunk

  // Push a new Thunk advancing the address of the top of the stack
  SHeap s |- (SPush(name, thunk), SEnv senv) -salloc-> (U(), SEnv senv')
  where
    allocupdate[s](senv, name, thunk) => senv'
  
  // Allocate a new location at the top of the SHeap and bind it to a placeholder
  SHeap s |- (SAlloc(name), SEnv senv) -salloc-> (U(), SEnv senv')
  where
    alloc[s](senv, name) => senv'
  
  // Allocate a new location at the top of the SHeap and bind it to a placeholder if no allocation for this name already exists
  SHeap s |- (SSoftAlloc(name), SEnv senv) -salloc->(U(), SEnv senv')
  where
    softalloc[s](senv, name) => senv'
  
  SHeap s |- (SUpdate(name, thunk), SEnv senv) -salloc-> (U(), SEnv senv')
  where
    update[s](senv, name, thunk) => senv'

  SParAlloc([]) -salloc-> U()
  
  SParAlloc([name | names]) -salloc-> U()
  where
    SAlloc(name) -salloc-> _,
    SParAlloc(names) -salloc-> _
  
    
