module state

imports
  semantics/shared
  semantics/stratego-signatures
  
/* === Rules for the Variables === */
signature

  native datatypes
    "ds.manual.interpreter.VState" as VHeap {
      lookup : VEnv * String -> Value
      alloc  : VEnv * String -> VEnv
      allocs : VEnv * List(String) -> VEnv
      update : VEnv * String * Value -> VEnv
      allocupdate : VEnv * String * Value -> VEnv
    }
    
    "ds.manual.interpreter.VBox" as VBox { }

  sorts
    VLookupResult
    
  aliases
    VEnv : Map<String, VBox>
  
  constructors
    VLookupResult : VEnv * Value -> VLookupResult

  sorts
    VHeapOp

  constructors
    VLookup : String -> VHeapOp
    VUpdate : String * Value -> VHeapOp
    VPushBatch : List(String) -> VHeapOp
    VPushUpdate : String * Value -> VHeapOp

  arrows
    VHeapOp -vlook-> Value
    VHeapOp -vupdate-> Unit 
    VHeapOp -vinit-> Unit

  variables
    venv : VEnv

rules 
  
  venv, VHeap s |- VLookup(x) -vlook-> v
  where
    lookup[s](venv, x) => v.
  
  VHeap s |- VUpdate(x, v) :: venv -vupdate-> U() :: venv'
  where
    update[s](venv, x, v) => venv'.

  VHeap s |- VPushBatch(xs) :: venv -vinit-> U() :: venv'
  where
    allocs[s](venv, xs) => venv'.
  
  VHeap s |- VPushUpdate(x, v) :: venv -vinit-> U() :: venv'
  where
    allocupdate[s](venv, x, v) => venv'.

/* === Rules for the Strategies === */

signature

  native datatypes
    "ds.manual.interpreter.SState" as SHeap {
      lookup : SEnv * String -> Thunk
      alloc  : SEnv * String -> SEnv
      softalloc: SEnv * String -> SEnv
      allocupdate : SEnv * String * Thunk -> SEnv
      update : SEnv * String * Thunk -> SEnv
    }
    
    "ds.manual.interpreter.SBox" as SBox { }

  sorts
    SLookupResult

  aliases
    SEnv : Map<String, SBox>

  constructors
    SLookupResult : SEnv * Thunk -> SLookupResult

  sorts
    Thunk
  
  constructors
    Thunk  : String * List(String) * List(String) * Strategy * VEnv * SEnv -> Thunk

  sorts
    SHeapOp
  
  constructors
    SAlloc: String -> SHeapOp
    SSoftAlloc: String -> SHeapOp
    SParAlloc : List(String) -> SHeapOp
    SUpdate : String * Thunk -> SHeapOp
    SPush: String * Thunk -> SHeapOp
    SLookup: String -> SHeapOp
    
  arrows
    SHeapOp -salloc-> Unit
    SHeapOp -slook-> Thunk
  
  variables
    senv : SEnv

rules

  // Lookup a thunk by name at the starting SHeap address
  SHeap s, senv |- SLookup(name) -slook-> thunk
  where
    lookup[s](senv, name) => thunk.

  // Push a new Thunk advancing the address of the top of the stack
  SHeap s |- SPush(name, thunk) :: senv -salloc-> U() :: senv'
  where
    allocupdate[s](senv, name, thunk) => senv'.
  
  // Allocate a new location at the top of the SHeap and bind it to a placeholder
  SHeap s |- SAlloc(name) :: senv -salloc-> U() :: senv'
  where
    alloc[s](senv, name) => senv'.
  
  // Allocate a new location at the top of the SHeap and bind it to a placeholder if no allocation for this name already exists
  SHeap s |- SSoftAlloc(name) :: senv -salloc-> U() :: senv'
  where
    softalloc[s](senv, name) => senv'.
  
  SHeap s |- SUpdate(name, thunk) :: senv -salloc-> U() :: senv'
  where
    update[s](senv, name, thunk) => senv'.

  SParAlloc([]) -salloc-> U().
  
  SParAlloc([name | names]) -salloc-> U()
  where
    SAlloc(name) -salloc-> _;
    SParAlloc(names) -salloc-> _.
  
    
