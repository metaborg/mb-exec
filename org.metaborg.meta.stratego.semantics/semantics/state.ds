module state

imports
  base
  shared
  stratego-signatures
  
/* === Rules for the Variables === */
signature

  semantic-components
    VEnv  -> Map<String, VBox>

  native-datatypes
    "ds.manual.interpreter.VState" as VHeap {
      lookup : VEnv * String -> Value
      alloc  : VEnv * String -> VEnv
      update : VEnv * String * Value -> VEnv
      allocupdate : VEnv * String * Value -> VEnv
    }
    
    "ds.manual.interpreter.VBox" as VBox { }

  internal-sorts
    VLookupResult
  
  internal-constructors
    VLookupResult : VEnv * Value -> VLookupResult

  internal-sorts
    VHeapOp

  internal-constructors
    VLookup : VEnv * String -> VHeapOp
    VUpdate : VEnv * String * Value -> VHeapOp
    VPush : VEnv * String -> VHeapOp
    VPushUpdate : VEnv * String * Value -> VHeapOp

  arrows
    VHeapOp -vlook-> VLookupResult
    VHeapOp -vupdate-> VEnv 
    VHeapOp -vinit-> VEnv
    
rules 
  
  (VLookup(venv, x), VHeap s) -vlook-> (VLookupResult(venv, v), VHeap s)
  where
    lookup[s](venv, x) => v
  
  (VUpdate(venv, x, v), VHeap s) -vupdate-> (venv, VHeap s)
  where
    update[s](venv, x, v) => venv'

  (VPush(venv, x), VHeap s) -vinit-> (venv', VHeap s)
  where
    alloc[s](venv, x) => venv'
  
  (VPushUpdate(venv, x, v), VHeap s) -vinit-> (venv', VHeap s)
  where
    allocupdate[s](venv, x, v) => venv'

/* === Rules for the Strategies === */

signature
  semantic-components
    SHeap -> Map<Int, Thunk>
    SEnv  -> Map<String, Int>

  internal-sorts
    SLookupResult

  internal-constructors
    SLookupResult : SEnv * Thunk -> SLookupResult

  internal-sorts
    Thunk
  
  internal-constructors
    Thunk  : String * List(String) * List(String) * Strategy * VEnv * SEnv -> Thunk
    ThunkPlaceholder: -> Thunk

  internal-sorts
    SHeapOp
  
  internal-constructors
    SAlloc: SEnv * String -> SHeapOp
    SParAlloc : SEnv * List(String) -> SHeapOp
    SUpdate : SEnv * String * Thunk -> SHeapOp
    SPush: SEnv * String * Thunk -> SHeapOp
    SLookup: SEnv * String -> SHeapOp
    
  arrows
    SHeapOp -slook-> SLookupResult
    SHeapOp -salloc-> SEnv
  
rules

  // Lookup a thunk by name at the starting SHeap address
  (SLookup(senv, name), SHeap s) -slook-> (SLookupResult(senv, thunk), SHeap s)
  where
    senv[name] => addr,
    s[addr] => thunk
  
  // Push a new Thunk advancing the address of the top of the stack
  (SPush(senv, name, thunk), SHeap s) -salloc-> (senv', SHeap s'')
  where
    (SAlloc(senv, name), SHeap s) -salloc-> (senv', SHeap s'),
    (SUpdate(senv', name, thunk), SHeap s') -salloc-> (senv'', SHeap s'')
  
  // Allocate a new location at the top of the SHeap and bind it to a placeholder
  (SAlloc(senv, name), SHeap s) -salloc-> ({ name |--> addr, senv}, SHeap s)
  where
    fresh => addr
  
  (SParAlloc(senv, []), SHeap s) -salloc-> (senv, SHeap s)
  
  (SParAlloc(senv, [name | names]), SHeap s) -salloc-> (senv'', SHeap s'')
  where
    (SAlloc(senv, name), SHeap s) -salloc-> (senv', SHeap s'),
    (SParAlloc(senv', names), SHeap s') -salloc-> (senv'', SHeap s'')
  
  (SUpdate(senv, name, thunk), SHeap s) -salloc-> (senv, SHeap { addr |--> thunk, s})
  where
    senv[name] => addr
    
