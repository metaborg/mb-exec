module state

imports
  base
  shared
  
signature

  semantic-components
    State -> Map<Int, Binding>
  
  internal-sorts
    Env

  internal-constructors
    Env  : Int -> Env

  internal-sorts
    Binding
    LookupResult
  
  internal-constructors
    Mt   : -> Binding
    Bind : String * Value * Int -> Binding
    LookupResult : Env * Binding -> LookupResult

  internal-sorts
    StateOp

  internal-constructors
    Lookup : Env * String -> StateOp
    Update : Env * String * Value -> StateOp
    Push : Env * String -> StateOp
    PushUpdate : Env * String * Value -> StateOp

  arrows
    StateOp -look-> LookupResult
    StateOp -update-> Env 
    StateOp -branch-> Env
    StateOp -init-> Env
    StateOp -pop-> Env
    
  native-operators
    asState : Map<Int, Binding> -> State

rules 
  
  (Lookup(Env(addr), x), State s) -look-> (LookupResult(Env(addr), Bind(y, v, addr')), State s)
  where
    s[addr] => Bind(y, v, addr'),
    x == y
  
  (Lookup(Env(addr), x), State s) -look-> (v', State s)
  where
    s[addr] => Bind(y, v, addr'),
    x != y,
    (Lookup(Env(addr'), x), State s) -look-> (v', State s')
  
  // (Lookup(Env(addr), x), State s) -look-> (LookupResult(Env(0), Mt()), State s)
  // where
  //   s[addr] => Mt()
  
  (Update(Env(addr), x, v_new), State s) -update-> (Env(addr), State { addr |--> Bind(x, v_new, addr''), s})
  where
    (Lookup(Env(addr), x), State s) -look-> (LookupResult(Env(addr'), Bind(y, v_old, addr'')), State s')
    // addr == addr'

  (Push(Env(addr), x), State s) -init-> (Env(addr'), State { addr' |--> Bind(x, F(), addr), s })
  where
    fresh => addr'
  
  PushUpdate(Env(addr), x, v) -init-> Env(addr')
  where
    Push(Env(addr), x) -init-> Env(addr'),
    Update(Env(addr'), x, v) -update-> Env(addr'')
  
  // (PopRange(env_start, env_end), State s) -pop-> (env_end, State s)
  // where
  //   env_start == env_end
  // 
  // (PopRange(env_start, env_end), State s) -pop-> (env_end', State s')
  // where
  //   env_start != env_end,
  //   s[env_start] => Bind(x, v, env_start'),
  //   (PopRange(env_start', env_end), State env_start \ s) -pop-> (env_end', State s')
