module helpers
imports
  lib

strategies

  is-subtype-of = fail
  
  emit-warn(|s) = where(<debug> s)
  
  dir-topdown(s) =
      ?base
    ; readdir 
    ; filter(not(?".") ; not(?".."))
    ; map({ x, y: ( x -> <concat-strings> [ base, "/", x ])}) => files
    ; <filter({ x: ?x ; filemode ; not(isdir) ; !x })
      ; filter(s)> files => r
    ; <filter({ x: ?x ; filemode ; isdir ; !x })
      ; map(dir-topdown(s))> files => r'
    ; <concat> [ r, r' ]
  
signature
  constructors
    TypeBinding  : List(String) * String * TypeBinding * List(TypeBinding) * Int * TypeBinding -> TypeBinding
    MethodBinding: TypeBinding * String * TypeBinding * List(TypeBinding) -> Term
        
strategies 

  //to-qualified-name = is-list ; debug(!"list case") ; ToQualifiedName
  //to-qualified-name = is-string ; debug(!"string case") ; string-tokenize(|['.']) ; debug(!"tokenized") ; ToQualifiedName
  
  //ToQualifiedName: [] -> SimpleName("")
  //ToQualifiedName: [x] -> SimpleName(x)
  //ToQualifiedName: [x | xs] -> QualifiedName(x, <ToQualifiedName> xs)
  
  to-dotted-name = ToDottedName ; concat-strings
  
  ToDottedName: [ x ] -> [ ".", x ]
  ToDottedName: [ x | xs ] -> [ x, "." | <ToDottedName> xs ]
  
  find-type-binding = fail
  type-of = ecj-type-of
  method-of = ecj-method-of
  is-cast-compatible = ecj-is-cast-compatible
  is-subtype-compatible = ecj-is-subtype-compatible
  emit-warn(|x) = where(<debug> x)
  
  list-contains(s) = not(filter(?s) => [])
  
  type-of-typedecl = 
     debug(!"type-of-typedecl")
   ; ecj-is-TypeDeclaration
   ; debug(!"yes")
   ; ?type
   ; prim("ECJ_type_of_typedecl", type)

  package-of: TypeBinding(p, _, _, _, _, _) -> <to-dotted-name> p
 
  supertype-of:
    TypeBinding(_, _, st, _, _, _) -> st
    
  dotted-name-of: 
    TypeBinding(_, n, _, _, _, _) -> n